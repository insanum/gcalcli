#!/usr/bin/env python2

# ** The MIT License **
#
# Copyright (c) 2007 Eric Davis (aka Insanum)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Dude... just buy us a beer. :-)
#

# XXX Todo/Cleanup XXX
# threading is currently broken when getting event list
# if threading works then move pageToken processing from GetAllEvents to thread
# support different types of reminders plus multiple ones (popup, sms, email)
# add caching, should be easy (dump all calendar JSON data to file)
# add support for multiline description input in the 'add' and 'edit' commands
# maybe add support for freebusy ?

#############################################################################
#                                                                           #
#                                      (           (     (                  #
#               (         (     (      )\ )   (    )\ )  )\ )               #
#               )\ )      )\    )\    (()/(   )\  (()/( (()/(               #
#              (()/(    (((_)((((_)(   /(_))(((_)  /(_)) /(_))              #
#               /(_))_  )\___ )\ _ )\ (_))  )\___ (_))  (_))                #
#              (_)) __|((/ __|(_)_\(_)| |  ((/ __|| |   |_ _|               #
#                | (_ | | (__  / _ \  | |__ | (__ | |__  | |                #
#                 \___|  \___|/_/ \_\ |____| \___||____||___|               #
#                                                                           #
# Author: Eric Davis <http://www.insanum.com>                               #
#         Brian Hartvigsen <http://github.com/tresni>                       #
# Home: https://github.com/insanum/gcalcli                                  #
#                                                                           #
# Requirements:                                                             #
#  - Python 2                                                               #
#        http://www.python.org                                              #
#  - Google APIs Client Library for Python 2                                #
#        https://developers.google.com/api-client-library/python            #
#  - dateutil Python 2 module                                               #
#        http://www.labix.org/python-dateutil                               #
#                                                                           #
# Optional:                                                                 #
#  - vobject Python module (needed for importing ics/vcal files)            #
#        http://vobject.skyhouseconsulting.com                              #
#  - parsedatetime Python module (needed for fuzzy date parsing)            #
#        https://github.com/bear/parsedatetime                              #
#                                                                           #
# Everything you need to know (Google API Calendar v3): http://goo.gl/HfTGQ #
#                                                                           #
#############################################################################

__program__         = 'gcalcli'
__version__         = 'v3.1'
__author__          = 'Eric Davis, Brian Hartvigsen'
__gcalcli_api_key__ = 'AIzaSyA6qJCdEnUiOX7Y79Ro5eA2toInxwWCikc'

try:
    import sys, os, re, urllib, getopt, shlex, subprocess, time
    import codecs, locale, csv, threading, textwrap, signal
    from Queue import Queue
    from ConfigParser import RawConfigParser
    from datetime import datetime, timedelta, date
    from dateutil.tz import *
    from dateutil.parser import *
    from dateutil.rrule import *
    from unicodedata import east_asian_width
    import httplib2
    from apiclient.discovery import build
    from oauth2client.file import Storage
    from oauth2client.client import OAuth2WebServerFlow
    from oauth2client.tools import run
    import cPickle as pickle
except ImportError, e:
    print "ERROR: Missing module - %s" % e.args[0]
    sys.exit(1)

try:
    from simplejson import json
except ImportError:
    import json

try:
    # If they have parsedatetime, we'll use it for fuzzy datetime comparison
    from parsedatetime import parsedatetime
except:
    class parsedatetime:
        class Calendar:
            def parse(self, string):
                return ([], 0)

def Version():
    sys.stdout.write(__program__+' '+__version__+' ('+__author__+')\n')
    sys.exit(1)


def Usage():
    sys.stdout.write('''
Usage:

gcalcli [options] command [command args]

 Options:

  --help                   this usage text

  --version                version information

  --config <file>          config file to read (default is '~/.gcalclirc')

  --cal <name>[#color]     'calendar' to work with (default is all calendars)
                           - you can specify a calendar by name or by substring
                             which can match multiple calendars
                           - you can use multiple '--cal' arguments on the
                             command line for the query commands
                           - in the config file specify multiple calendars in
                             quotes separated by commas as:
                               cal: "foo", "bar", "my cal"
                           - an optional color override can be specified per
                             calendar using the ending hashtag:
                               --cal "Eric Davis"#green --cal foo#red
                             or via the config file:
                               cal: "foo"#red, "bar"#yellow, "my cal"#green

  --24hr                   show all dates in 24 hour format

  --detail-all             show event details in the 'agenda' output
  --detail-location        - the description width defaults to 80 characters
  --detail-length          - if 'short' is specified for the url then the event
  --detail-reminders         link is shortened using http://goo.gl (slow!)
  --detail-descr           - the --detail-url can be used for both the 'quick'
  --detail-descr-width       and 'add' commands as well
  --detail-url [short,
                long]

  --ignore-started         ignore old or already started events
                           - when used with the 'agenda' command, ignore events
                             that have already started and are in-progress with
                             respect to the specified [start] time
                           - when used with the 'search' command, ignore events
                             that have already occurred and only show future
                             events

  --width                  the number of characters to use for each column in
                           the 'calw' and 'calm' command outputs (default is 10)

  --mon                    week begins with Monday for 'calw' and 'calm' command
                           outputs (default is Sunday)

  --nc                     don't use colors

  --nl                     don't use line graphics

  --conky                  use conky color escapes sequences instead of ansi
                           terminal color escape sequences (requires using
                           the 'execpi' command in your conkyrc)

  --cal-owner-color        specify the colors used for the calendars and dates
  --cal-writer-color       each of these argument requires a <color> argument
  --cal-reader-color       which must be one of [ default, black, brightblack,
  --cal-freebusy-color     red, brightred, green, brightgreen, yellow,
  --date-color             brightyellow, blue, brightblue, magenta,
  --now-marker-color       brightmagenta, cyan, brightcyan, white,
  --border-color           brightwhite ]

  --tsv                    tab-separated output for 'agenda'. Format is:
                           date, start, end, link, title, location, description

  --locale <locale>        set a custom locale (i.e. 'de_DE.UTF-8'). Check the
                           supported locales of your system first.

  --reminder <mins>        number of minutes to use when setting reminders for
                           the 'quick' and 'add' commands; if not specified
                           the calendar's default reminder settings are used

   --title <title>         event details used by the 'add' command
   --where <location>      - the duration is specified in minutes
   --when <datetime>       - make sure to quote strings with spaces
   --duration <#>          - datetime examples see 'agenda' below
   --descr <description>

   --refresh               delete and refresh the cache
   --no-cache              execute the command without using any cached data

 Commands:

  list                     list all calendars

  search <text>            search for events
                           - case insensitive search terms to find events that
                             match these terms in any field, like traditional
                             Google search with quotes, exclusion, etc.
                           - for example to get just games: "soccer -practice"

  agenda [start] [end]     get an agenda for a time period
                           - start time default is 12am today
                           - end time default is 5 days from start
                           - example time strings:
                              '9/24/2007'
                              '24/09/2007'
                              '24/9/07'
                              'Sep 24 2007 3:30pm'
                              '2007-09-24T15:30'
                              '2007-09-24T15:30-8:00'
                              '20070924T15'
                              '8am'

  calw <weeks> [start]     get a week based agenda in a nice calendar format
                           - weeks is the number of weeks to display
                           - start time default is beginning of this week
                           - note that all events for the week(s) are displayed

  calm [start]             get a month agenda in a nice calendar format
                           - start time default is the beginning of this month
                           - note that all events for the month are displayed
                             and only one month will be displayed

  quick <text>             quick add an event to a calendar
                           - a single --cal must specified
                           - the --detail-url option will show the event link
                           - example text:
                              'Dinner with Eric 7pm tomorrow'
                              '5pm 10/31 Trick or Treat'

  add                      add a detailed event to a calendar
                           - a single --cal must specified
                           - the --detail-url option will show the event link
                           - example:
                              gcalcli --cal 'Eric Davis'
                                      --title 'Analysis of Algorithms Final'
                                      --where UCI
                                      --when '12/14/2012 10:00'
                                      --duration 60
                                      --descr 'It is going to be hard!'
                                      --reminder 30
                                      add

  delete <text>            delete event(s)
                           - case insensitive search terms to find and delete
                             events, just like the 'search' command
                           - deleting is interactive
                             use the --iama-expert option to auto delete
                             THINK YOU'RE AN EXPERT? USE AT YOUR OWN RISK!!!
                           - use the --detail options to show event details

  edit <text>              edit event(s)
                           - case insensitive search terms to find and edit
                             events, just like the 'search' command
                           - editing is interactive

  import [-v] [file]       import an ics/vcal file to a calendar
                           - a single --cal must specified
                           - if a file is not specified then the data is read
                             from standard input
                           - if -v is given then each event in the file is
                             displayed and you're given the option to import
                             or skip it, by default everything is imported
                             quietly without any interaction

  remind <mins> <command>  execute command if event occurs within <mins>
                           minutes time ('%s' in <command> is replaced with
                           event start time and title text)
                           - <mins> default is 10
                           - default command:
                              'notify-send -u critical -a gcalcli %s'

''')
    sys.exit(1)


class CLR:

    useColor = True
    conky    = False

    def __str__(self):
        return self.color if self.useColor else ""

class CLR_NRM(CLR):   color = "\033[0m"
class CLR_BLK(CLR):   color = "\033[0;30m"
class CLR_BRBLK(CLR): color = "\033[30;1m"
class CLR_RED(CLR):   color = "\033[0;31m"
class CLR_BRRED(CLR): color = "\033[31;1m"
class CLR_GRN(CLR):   color = "\033[0;32m"
class CLR_BRGRN(CLR): color = "\033[32;1m"
class CLR_YLW(CLR):   color = "\033[0;33m"
class CLR_BRYLW(CLR): color = "\033[33;1m"
class CLR_BLU(CLR):   color = "\033[0;34m"
class CLR_BRBLU(CLR): color = "\033[34;1m"
class CLR_MAG(CLR):   color = "\033[0;35m"
class CLR_BRMAG(CLR): color = "\033[35;1m"
class CLR_CYN(CLR):   color = "\033[0;36m"
class CLR_BRCYN(CLR): color = "\033[36;1m"
class CLR_WHT(CLR):   color = "\033[0;37m"
class CLR_BRWHT(CLR): color = "\033[37;1m"


def SetConkyColors():
    # XXX these colors should be configurable
    CLR.conky       = True
    CLR_NRM.color   = ""
    CLR_BLK.color   = "${color black}"
    CLR_BRBLK.color = "${color black}"
    CLR_RED.color   = "${color red}"
    CLR_BRRED.color = "${color red}"
    CLR_GRN.color   = "${color green}"
    CLR_BRGRN.color = "${color green}"
    CLR_YLW.color   = "${color yellow}"
    CLR_BRYLW.color = "${color yellow}"
    CLR_BLU.color   = "${color blue}"
    CLR_BRBLU.color = "${color blue}"
    CLR_MAG.color   = "${color magenta}"
    CLR_BRMAG.color = "${color magenta}"
    CLR_CYN.color   = "${color cyan}"
    CLR_BRCYN.color = "${color cyan}"
    CLR_WHT.color   = "${color white}"
    CLR_BRWHT.color = "${color white}"


class ART:

    useArt = True
    fancy  = ''
    plain  = ''

    def __str__(self):
        return self.fancy if self.useArt else self.plain

class ART_HRZ(ART): fancy = '\033(0\x71\033(B' ; plain = '-'
class ART_VRT(ART): fancy = '\033(0\x78\033(B' ; plain = '|'
class ART_LRC(ART): fancy = '\033(0\x6A\033(B' ; plain = '+'
class ART_URC(ART): fancy = '\033(0\x6B\033(B' ; plain = '+'
class ART_ULC(ART): fancy = '\033(0\x6C\033(B' ; plain = '+'
class ART_LLC(ART): fancy = '\033(0\x6D\033(B' ; plain = '+'
class ART_CRS(ART): fancy = '\033(0\x6E\033(B' ; plain = '+'
class ART_LTE(ART): fancy = '\033(0\x74\033(B' ; plain = '+'
class ART_RTE(ART): fancy = '\033(0\x75\033(B' ; plain = '+'
class ART_BTE(ART): fancy = '\033(0\x76\033(B' ; plain = '+'
class ART_UTE(ART): fancy = '\033(0\x77\033(B' ; plain = '+'


def PrintErrMsg(msg):
    if CLR.useColor:
        sys.stdout.write(str(CLR_BRRED()))
        sys.stdout.write(msg)
        sys.stdout.write(str(CLR_NRM()))
    else:
        sys.stdout.write(msg)


def PrintMsg(color, msg):
    if CLR.useColor:
        sys.stdout.write(str(color))
        sys.stdout.write(msg)
        sys.stdout.write(str(CLR_NRM()))
    else:
        sys.stdout.write(msg)


def DebugPrint(msg):
    return
    sys.stdout.write(str(CLR_YLW()))
    sys.stdout.write(msg)
    sys.stdout.write(str(CLR_NRM()))


def dprint(obj):
    try:
        from pprint import pprint
        pprint(obj)
    except ImportError, e:
        print obj


class DateTimeParser:
    def __init__(self):
        self.pdtCalendar = parsedatetime.Calendar()

    def fromString(self, eWhen, useMidnight=True):
        if useMidnight:
            defaultDateTime = datetime.now(tzlocal()).replace(hour=0,
                                                     minute=0,
                                                     second=0,
                                                     microsecond=0)
        else:
            defaultDateTime = datetime.now(tzlocal())

        try:
            eTimeStart = parse(eWhen, default=defaultDateTime)
        except:
            struct, result = self.pdtCalendar.parse(eWhen)
            eTimeStart = datetime.fromtimestamp(time.mktime(struct), tzlocal())
            if not result:
                raise ValueError("Date and time is invalid")


        return eTimeStart


def GetTimeFromStr(eWhen, eDuration=0):
    dtp = DateTimeParser()

    try:
        eTimeStart = dtp.fromString(eWhen)
    except:
        PrintErrMsg('Date and time is invalid!\n')
        sys.exit(1)

    try:
        eTimeStop = eTimeStart + timedelta(minutes=float(eDuration))
    except:
        PrintErrMsg('Duration time (minutes) is invalid\n')
        sys.exit(1)

    sTimeStart = eTimeStart.isoformat()
    sTimeStop = eTimeStop.isoformat()

    return sTimeStart, sTimeStop


def PrintVobjEvent(ve):

    if hasattr(ve, 'summary'):
        print "Event........%s" % ve.summary.value

    if hasattr(ve, 'location'):
        print "Location.....%s" % ve.location.value

    if not hasattr(ve, 'dtstart') or not hasattr(ve, 'dtend'):
        PrintErrMsg("Error: event does not have a dtstart and dtend!\n")
        return None

    print "Start........%s" % ve.dtstart.value.isoformat(' ')
    print "End..........%s" % ve.dtend.value.isoformat(' ')
    print "Local Start..%s" % ve.dtstart.value.astimezone(tzlocal())
    print "Local End....%s" % ve.dtend.value.astimezone(tzlocal())

    if hasattr(ve, 'rrule'):
        print "Recurrence...%s" % ve.rrule.value

    if hasattr(ve, 'description') and ve.description.value.strip():
        descr = ve.description.value.strip()
        print "Description:\n%s" % descr

    if hasattr(ve, 'organizer'):
        if ve.organizer.value.startswith("MAILTO:"):
            email = ve.organizer.value[7:]
        else:
            email = ve.organizer.value
        print "Organizer:\n %s" % email

    if hasattr(ve, 'attendee_list'):
        print "Attendees:"
        for attendee in ve.attendee_list:
            if attendee.value.startswith("MAILTO:"):
                email = attendee.value[7:]
            else:
                email = attendee.value
            print " %s" % email


def DumpICS(icsFile):

    try:
        import vobject
    except:
        PrintErrMsg('Python vobject module not installed!\n')
        sys.exit(1)

    try:
        f = file(icsFile)
    except Exception, e:
        PrintErrMsg("Error: " + str(e) + "!\n")
        sys.exit(1)

    while True:

        try:
            v = vobject.readComponents(f).next()
        except StopIteration:
            break

        for ve in v.vevent_list:
            PrintVobjEvent(ve)

    sys.exit(0)


class gcalcli:

    cache         = {}
    refreshCache  = False
    useCache      = True
    allCals       = []
    allEvents     = []
    cals          = []
    now           = datetime.now(tzlocal())
    agendaLength  = 5
    authHttp      = None
    calService    = None
    urlService    = None
    military      = False
    ignoreStarted = False
    calWidth      = 10
    calMonday     = False
    command       = 'notify-send -u critical -a gcalcli %s'
    tsv           = False
    customLocale  = None
    dateParser    = DateTimeParser()

    detailCalendar   = False
    detailLocation   = False
    detailLength     = False
    detailReminders  = False
    detailDescr      = False
    detailDescrWidth = 80
    detailUrl        = None

    calOwnerColor    = CLR_CYN()
    calWriterColor   = CLR_GRN()
    calReaderColor   = CLR_MAG()
    calFreeBusyColor = CLR_NRM()
    dateColor        = CLR_YLW()
    nowMarkerColor   = CLR_BRRED()
    borderColor      = CLR_WHT()

    ACCESS_OWNER    = 'owner'
    ACCESS_WRITER   = 'writer'
    ACCESS_READER   = 'reader'
    ACCESS_FREEBUSY = 'freeBusyReader'

    def __init__(self,
                 calNames=[],
                 calNameColors=[],
                 military=False,
                 detailCalendar=False,
                 detailLocation=False,
                 detailLength=False,
                 detailReminders=False,
                 detailDescr=False,
                 detailDescrWidth=80,
                 detailUrl=None,
                 ignoreStarted=False,
                 calWidth=10,
                 calMonday=False,
                 calOwnerColor=CLR_CYN(),
                 calWriterColor=CLR_GRN(),
                 calReaderColor=CLR_MAG(),
                 calFreeBusyColor=CLR_NRM(),
                 dateColor=CLR_YLW(),
                 nowMarkerColor=CLR_BRRED(),
                 borderColor=CLR_WHT(),
                 tsv=False,
                 customLocale=None,
                 refreshCache=False,
                 useCache=True):

        self.military      = military
        self.ignoreStarted = ignoreStarted
        self.calWidth      = calWidth
        self.calMonday     = calMonday
        self.tsv           = tsv
        self.customLocale  = customLocale
        self.refreshCache  = refreshCache
        self.useCache      = useCache

        self.detailCalendar   = detailCalendar
        self.detailLocation   = detailLocation
        self.detailLength     = detailLength
        self.detailReminders  = detailReminders
        self.detailDescr      = detailDescr
        self.detailDescrWidth = detailDescrWidth
        self.detailUrl        = detailUrl

        self.calOwnerColor    = calOwnerColor
        self.calWriterColor   = calWriterColor
        self.calReaderColor   = calReaderColor
        self.calFreeBusyColor = calFreeBusyColor
        self.dateColor        = dateColor
        self.nowMarkerColor   = nowMarkerColor
        self.borderColor      = borderColor

        # set customLocale if correct
        try:
            locale.setlocale(locale.LC_ALL, customLocale)
        except Exception, e:
            PrintErrMsg("Error: " + str(e) + "!\n" +
                        "Check supported locales of your system.\n")
            sys.exit(1)

        self._GetCached()

        for cal in self.allCals:
            if len(calNames):
                for i in xrange(len(calNames)):
                    if re.search(calNames[i].lower(), cal['summary'].lower()):
                        self.cals.append(cal)
                        cal['colorSpec'] = calNameColors[i]
            else:
                self.cals.append(cal)
                cal['colorSpec'] = None


    def _GoogleAuth(self):
        if not self.authHttp:
            storage = Storage(os.path.expanduser('~') + '/.gcalcli_oauth')
            credentials = storage.get()

            if credentials is None or credentials.invalid == True:
                credentials = run(
                    OAuth2WebServerFlow(
                        client_id='232867676714.apps.googleusercontent.com',
                        client_secret='3tZSxItw6_VnZMezQwC8lUqy',
                        scope=['https://www.googleapis.com/auth/calendar',
                               'https://www.googleapis.com/auth/urlshortener'],
                        user_agent=__program__+'/'+__version__),
                    storage)

            self.authHttp = credentials.authorize(httplib2.Http())

        return self.authHttp


    def _CalService(self):
        if not self.calService:
            self.calService = \
                 build(serviceName='calendar',
                       version='v3',
                       http=self._GoogleAuth(),
                       developerKey='AIzaSyA6qJCdEnUiOX7Y79Ro5eA2toInxwWCikc')

        return self.calService


    def _UrlService(self):
        if not self.urlService:
            self._GoogleAuth()
            self.urlService = \
                 build(serviceName='urlshortener',
                       version='v1',
                       http=self._GoogleAuth(),
                       developerKey='AIzaSyA6qJCdEnUiOX7Y79Ro5eA2toInxwWCikc')

        return self.urlService


    def _GetCached(self):
        cacheFile = os.path.expanduser('~') + '/.gcalcli_cache'

        if self.refreshCache:
            try:
                os.remove(cacheFile)
            except OSError:
                pass
                # fall through

        self.cache     = {}
        self.allCals   = []
        self.allEvents = []

        if self.useCache:
            # note that we need to use pickle for cache data since we stuff
            # various non-JSON data in the runtime storage structures
            try:
                with open(cacheFile, 'rb') as _cache_:
                    self.cache     = pickle.load(_cache_)
                    self.allCals   = self.cache['allCals']
                    self.allEvents = self.cache['allEvents']
                # XXX assuming data is valid, need some verification check here
                return
            except IOError:
                pass
                # fall through

        calList = self._CalService().calendarList().list().execute()

        while True:
            for cal in calList['items']:
                self.allCals.append(cal)
            pageToken = calList.get('nextPageToken')
            if pageToken:
                calList = self._CalService().calendarList().\
                          list(pageToken = pageToken).execute()
            else:
                break

        # gcalcli defined way to order calendars
        order = { self.ACCESS_OWNER    : 1,
                  self.ACCESS_WRITER   : 2,
                  self.ACCESS_READER   : 3,
                  self.ACCESS_FREEBUSY : 4 }

        self.allCals.sort(lambda x, y:
                           cmp(order[x['accessRole']],
                               order[y['accessRole']]))

        for cal in self.allCals:

            events = self._CalService().events().\
                     list(calendarId = cal['id'],
                          singleEvents = False).execute()

            while True:
                if 'items' not in events:
                    break

                for event in events['items']:

                    event['gcalcli_cal'] = cal

                    if 'status' in event and event['status'] == 'cancelled':
                        continue

                    if 'dateTime' in event['start']:
                        event['s'] = parse(event['start']['dateTime'])
                    else:
                        # all day events
                        event['s'] = parse(event['start']['date'])

                    if event['s'].tzinfo == None:
                        event['s'] = event['s'].replace(tzinfo=tzlocal())
                    else:
                        event['s'] = event['s'].astimezone(tzlocal())

                    if 'dateTime' in event['end']:
                        event['e'] = parse(event['end']['dateTime'])
                    else:
                        # all day events
                        event['e'] = parse(event['end']['date'])

                    if event['e'].tzinfo == None:
                        event['e'] = event['e'].replace(tzinfo=tzlocal())
                    else:
                        event['e'] = event['e'].astimezone(tzlocal())

                    # http://en.wikipedia.org/wiki/Year_2038_problem
                    # Catch the year 2038 problem here as the python dateutil
                    # module can choke throwing a ValueError exception. If
                    # either the start or end time for an event has a year
                    # '>= 2038' dump it.
                    if event['s'].year >= 2038 or event['e'].year >= 2038:
                        continue

                    self.allEvents.append(event)

                pageToken = events.get('nextPageToken')
                if pageToken:
                    events = self._CalService().events().\
                             list(calendarId = cal['id'],
                                  singleEvents = False,
                                  pageToken = pageToken).execute()
                else:
                    break

        # sort all events across all calendars together
        self.allEvents.sort(lambda x, y: cmp(x['s'], y['s']))

        if self.useCache:
            self.cache['allCals']   = self.allCals
            self.cache['allEvents'] = self.allEvents
            with open(cacheFile, 'wb') as _cache_:
                pickle.dump(self.cache, _cache_)


    def _ShortenURL(self, url):
        if self.detailUrl != "short":
            return url
        # Note that when authenticated to a google account different shortUrls
        # can be returned for the same longUrl. See: http://goo.gl/Ya0A9
        shortUrl = self._UrlService().url().insert(body={'longUrl':url}).execute()
        return shortUrl['id']


    def _CalendarColor(self, cal):

        if cal == None:
            return CLR_NRM()
        elif 'colorSpec' in cal and cal['colorSpec'] != None:
            return cal['colorSpec']
        elif cal['accessRole'] == self.ACCESS_OWNER:
            return self.calOwnerColor
        elif cal['accessRole'] == self.ACCESS_WRITER:
            return self.calWriterColor
        elif cal['accessRole'] == self.ACCESS_READER:
            return self.calReaderColor
        elif cal['accessRole'] == self.ACCESS_FREEBUSY:
            return self.calFreeBusyColor
        else:
            return CLR_NRM()


    def _ValidTitle(self, event):
        if 'summary' in event and event['summary'].strip():
            return event['summary']
        else:
            return "(No title)"


    def _GetWeekEventStrings(self, cmd, curMonth,
                             startDateTime, endDateTime, eventList):

        weekEventStrings = [ '', '', '', '', '', '', '' ]

        nowMarkerPrinted = False
        if self.now < startDateTime or self.now > endDateTime:
            # now isn't in this week
            nowMarkerPrinted = True

        for event in eventList:

            if cmd == 'calm' and curMonth != event['s'].strftime("%b"):
                continue

            dayNum = int(event['s'].strftime("%w"))
            if self.calMonday:
                dayNum -= 1
                if dayNum < 0:
                    dayNum = 6

            if event['s'] >= startDateTime and event['s'] < endDateTime:

                forceEventColorAsMarker = False

                if event['s'].hour == 0 and event['s'].minute == 0 and \
                   event['e'].hour == 0 and event['e'].minute == 0:
                    tmpTimeStr = ''
                else:
                    if not nowMarkerPrinted:
                        if self.now <= event['s']:
                            # add a line marker before next event
                            nowMarkerPrinted = True
                            weekEventStrings[dayNum] += \
                                ("\n" +
                                 str(self.nowMarkerColor) +
                                 (self.calWidth * '-'))
                        elif self.now >= event['s'] and self.now <= event['e']:
                            # line marker is during the event (recolor event)
                            nowMarkerPrinted = True
                            forceEventColorAsMarker = True

                    if self.military:
                        tmpTimeStr = event['s'].strftime("%H:%M")
                    else:
                        tmpTimeStr = \
                            event['s'].strftime("%I:%M").lstrip('0') + \
                            event['s'].strftime('%p').lower()

                if forceEventColorAsMarker:
                    eventColor = self.nowMarkerColor
                else:
                    eventColor = self._CalendarColor(event['gcalcli_cal'])

                # newline and empty string are the keys to turn off coloring
                weekEventStrings[dayNum] += \
                    "\n" + \
                    str(eventColor) + \
                    tmpTimeStr.strip() + \
                    " " + \
                    self._ValidTitle(event).strip()

        return weekEventStrings


    UNIWIDTH = {'W': 2, 'F': 2, 'N': 1, 'Na': 1, 'H': 1, 'A': 1}


    def _PrintLen(self, string):
        printLen = 0
        for tmpChar in string:
            printLen += self.UNIWIDTH[east_asian_width(tmpChar)]
        return printLen


    # return print length before cut, cut index, and force cut flag
    def _NextCut(self, string, curPrintLen):
        idx = 0
        printLen = 0
        for tmpChar in string:
            if (curPrintLen + printLen) >= self.calWidth:
                return (printLen, idx, True)
            if tmpChar in (' ', '\n'):
                return (printLen, idx, False)
            idx += 1
            printLen += self.UNIWIDTH[east_asian_width(tmpChar)]
        return (printLen, -1, False)


    def _GetCutIndex(self, eventString):

        printLen = self._PrintLen(eventString)

        if printLen <= self.calWidth:
            DebugPrint("------ printLen=%d (end of string)\n" % printLen)
            return (printLen, len(eventString))

        cutWidth, cut, forceCut = self._NextCut(eventString, 0)
        DebugPrint("------ cutWidth=%d cut=%d \"%s\"\n" %
                   (cutWidth, cut, eventString))

        if forceCut:
            DebugPrint("--- forceCut cutWidth=%d cut=%d\n" % (cutWidth, cut))
            return (cutWidth, cut)

        DebugPrint("--- looping\n")

        while cutWidth < self.calWidth:

            DebugPrint("--- cutWidth=%d cut=%d \"%s\"\n" %
                       (cutWidth, cut, eventString[cut:]))

            while cut < self.calWidth and \
                  cut < printLen and \
                  eventString[cut] == ' ':
                DebugPrint("-> skipping space <-\n")
                cutWidth += 1
                cut += 1

            DebugPrint("--- cutWidth=%d cut=%d \"%s\"\n" %
                       (cutWidth, cut, eventString[cut:]))

            nextCutWidth, nextCut, forceCut = \
                self._NextCut(eventString[cut:], cutWidth)

            if forceCut:
                DebugPrint("--- forceCut cutWidth=%d cut=%d\n" % (cutWidth, cut))
                break

            cutWidth += nextCutWidth
            cut += nextCut

            if eventString[cut] == '\n':
                break

            DebugPrint("--- loop cutWidth=%d cut=%d\n" % (cutWidth, cut))

        return (cutWidth, cut)


    def _GraphEvents(self, cmd, startDateTime, count, eventList):

        # ignore started events (i.e. that start previous day and end start day)
        while (len(eventList) and eventList[0]['s'] < startDateTime):
            eventList = eventList[1:]

        dayWidthLine = (self.calWidth * str(ART_HRZ()))

        topWeekDivider = (str(self.borderColor) +
                          str(ART_ULC()) + dayWidthLine +
                          (6 * (str(ART_UTE()) + dayWidthLine)) +
                          str(ART_URC()) + str(CLR_NRM()))

        midWeekDivider = (str(self.borderColor) +
                          str(ART_LTE()) + dayWidthLine +
                          (6 * (str(ART_CRS()) + dayWidthLine)) +
                          str(ART_RTE()) + str(CLR_NRM()))

        botWeekDivider = (str(self.borderColor) +
                          str(ART_LLC()) + dayWidthLine +
                          (6 * (str(ART_BTE()) + dayWidthLine)) +
                          str(ART_LRC()) + str(CLR_NRM()))

        empty       = self.calWidth * ' '

        dayFormat = '%-' + str(self.calWidth) + '.' + str(self.calWidth) + 's'

        # Get the localized day names... January 1, 2001 was a Monday
        dayNames = [ date(2001, 1, i+1).strftime('%A') for i in range(7) ]
        dayNames = dayNames[6:] + dayNames[:6]

        dayHeader = str(self.borderColor) + str(ART_VRT()) + str(CLR_NRM())
        for i in xrange(7):
            if self.calMonday:
                if i == 6:
                    dayName = dayFormat % (dayNames[0])
                else:
                    dayName = dayFormat % (dayNames[i+1])
            else:
                dayName = dayFormat % (dayNames[i])
            dayHeader += str(self.dateColor) + dayName + str(CLR_NRM())
            dayHeader += str(self.borderColor) + str(ART_VRT()) + str(CLR_NRM())

        if cmd == 'calm':
            topMonthDivider = (str(self.borderColor) +
                               str(ART_ULC()) + dayWidthLine +
                               (6 * (str(ART_HRZ()) + dayWidthLine)) +
                               str(ART_URC()) + str(CLR_NRM()))
            PrintMsg(CLR_NRM(), "\n" + topMonthDivider + "\n")

            m = startDateTime.strftime('%B %Y')
            mw = str((self.calWidth * 7) + 6)
            mwf = '%-' + mw + '.' + mw + 's'
            PrintMsg(CLR_NRM(),
                     str(self.borderColor) +
                     str(ART_VRT()) +
                     str(CLR_NRM()) +
                     str(self.dateColor) +
                     mwf % (m) +
                     str(CLR_NRM()) +
                     str(self.borderColor) +
                     str(ART_VRT()) +
                     str(CLR_NRM()) +
                     '\n')

            botMonthDivider = (str(self.borderColor) +
                               str(ART_LTE()) + dayWidthLine +
                               (6 * (str(ART_UTE()) + dayWidthLine)) +
                               str(ART_RTE()) + str(CLR_NRM()))
            PrintMsg(CLR_NRM(), botMonthDivider + "\n")

        else: # calw
            PrintMsg(CLR_NRM(), "\n" + topWeekDivider + "\n")

        PrintMsg(CLR_NRM(), dayHeader + "\n")
        PrintMsg(CLR_NRM(), midWeekDivider + "\n")

        curMonth = startDateTime.strftime("%b")

        # get date range objects for the first week
        if cmd == 'calm':
            dayNum = int(startDateTime.strftime("%w"))
            if self.calMonday:
                dayNum -= 1
                if dayNum < 0:
                    dayNum = 6
            startDateTime = (startDateTime - timedelta(days=dayNum))
        startWeekDateTime = startDateTime
        endWeekDateTime = (startWeekDateTime + timedelta(days=7))

        for i in xrange(count):

            # create/print date line
            line = str(self.borderColor) + str(ART_VRT()) + str(CLR_NRM())
            for j in xrange(7):
                if cmd == 'calw':
                    d = (startWeekDateTime +
                         timedelta(days=j)).strftime("%d %b")
                else: # (cmd == 'calm'):
                    d = (startWeekDateTime +
                         timedelta(days=j)).strftime("%d")
                    if curMonth != (startWeekDateTime + \
                                    timedelta(days=j)).strftime("%b"):
                        d = ''
                tmpDateColor = self.dateColor
                tmpTodayMarker = ''
                if self.now.strftime("%d%b%Y") == \
                   (startWeekDateTime + timedelta(days=j)).strftime("%d%b%Y"):
                    tmpDateColor = self.nowMarkerColor
                    tmpTodayMarker = " **"
                line += str(tmpDateColor) + \
                            dayFormat % (d + tmpTodayMarker) + \
                        str(CLR_NRM()) + \
                        str(self.borderColor) + \
                            str(ART_VRT()) + \
                        str(CLR_NRM())
            PrintMsg(CLR_NRM(), line + "\n")

            weekColorStrings = [ '', '', '', '', '', '', '' ]
            weekEventStrings = self._GetWeekEventStrings(cmd, curMonth,
                                                         startWeekDateTime,
                                                         endWeekDateTime,
                                                         eventList)

            # convert the strings to unicode for various string ops
            # XXX event strings are already in unicode for Calendar v3 APIs
            #for j in xrange(7):
            #    weekEventStrings[j] = unicode(weekEventStrings[j],
            #                                  locale.getpreferredencoding())

            # get date range objects for the next week
            startWeekDateTime = endWeekDateTime
            endWeekDateTime = (endWeekDateTime + timedelta(days=7))

            while 1:

                done = True
                line = str(self.borderColor) + str(ART_VRT()) + str(CLR_NRM())

                for j in xrange(7):

                    if weekEventStrings[j] == '':
                        weekColorStrings[j] = ''
                        line += (empty +
                                 str(self.borderColor) +
                                 str(ART_VRT()) +
                                 str(CLR_NRM()))
                        continue

                    # get/skip over a color sequence
                    if ((not CLR.conky and weekEventStrings[j][0] == '\033') or
                        (    CLR.conky and weekEventStrings[j][0] == '$')):
                        weekColorStrings[j] = ''
                        while ((not CLR.conky and weekEventStrings[j][0] != 'm') or
                               (    CLR.conky and weekEventStrings[j][0] != '}')):
                            weekColorStrings[j] += weekEventStrings[j][0]
                            weekEventStrings[j] = weekEventStrings[j][1:]
                        weekColorStrings[j] += weekEventStrings[j][0]
                        weekEventStrings[j] = weekEventStrings[j][1:]

                    if weekEventStrings[j][0] == '\n':
                        weekColorStrings[j] = ''
                        weekEventStrings[j] = weekEventStrings[j][1:]
                        line += (empty +
                                 str(self.borderColor) +
                                 str(ART_VRT()) +
                                 str(CLR_NRM()))
                        done = False
                        continue

                    weekEventStrings[j] = weekEventStrings[j].lstrip()

                    printLen, cut = self._GetCutIndex(weekEventStrings[j])
                    padding = ' ' * (self.calWidth - printLen)

                    line += (weekColorStrings[j] +
                             weekEventStrings[j][:cut] +
                             padding +
                             str(CLR_NRM()))
                    weekEventStrings[j] = weekEventStrings[j][cut:]

                    done = False
                    line += (str(self.borderColor) +
                             str(ART_VRT()) +
                             str(CLR_NRM()))

                if done:
                    break

                PrintMsg(CLR_NRM(), line + "\n")

            if i < range(count)[len(range(count))-1]:
                PrintMsg(CLR_NRM(), midWeekDivider + "\n")
            else:
                PrintMsg(CLR_NRM(), botWeekDivider + "\n")


    def _tsv(self, startDateTime, eventList):
        for event in eventList:
            tmpLink    = self._ShortenURL(event['htmlLink'])
            tmpDayStr  = event['s'].strftime('%F')
            tmpDayStp  = event['e'].strftime('%F')
            tmpTimeStr = event['s'].strftime("%H:%M")
            tmpTimeStp = event['e'].strftime("%H:%M")
            tmpWhere = ''
            if 'location' in event and event['location'].strip():
                tmpWhere = event['location'].strip()
            tmpContent = ''
            if 'description' in event and event['description'].strip():
                tmpContent = event['description'].strip()
            xstr = "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s" % (
                tmpDayStr,
                tmpTimeStr,
                tmpDayStp,
                tmpTimeStp,
                tmpLink,
                self._ValidTitle(event).strip(),
                tmpWhere,
                tmpContent
            )
            xstr2 = "%s\n" % xstr.replace('\n', '''\\n''')
            sys.stdout.write(xstr2)


    def _PrintEvent(self, event, prefix):

        def _formatDescr(descr, indent, box):
            wrapper = textwrap.TextWrapper()
            if box:
                wrapper.initial_indent = (indent + '  ')
                wrapper.subsequent_indent = (indent + '  ')
                wrapper.width = (self.detailDescrWidth - 2)
            else:
                wrapper.initial_indent = indent
                wrapper.subsequent_indent = indent
                wrapper.width = self.detailDescrWidth
            new_descr = ""
            for line in descr.split("\n"):
                if box:
                    tmpLine = wrapper.fill(line)
                    for singleLine in tmpLine.split("\n"):
                        singleLine = singleLine.ljust(self.detailDescrWidth,' ')
                        new_descr += singleLine[:len(indent)] + \
                                     str(ART_VRT()) + \
                                     singleLine[(len(indent)+1) :
                                                (self.detailDescrWidth-1)] + \
                                     str(ART_VRT()) + '\n'
                else:
                    new_descr += wrapper.fill(line) + "\n"
            return new_descr.rstrip()

        indent = 10 * ' '
        detailsIndent = 19 * ' '

        if self.military:
            timeFormat = '%-5s'
            tmpTimeStr = event['s'].strftime("%H:%M")
        else:
            timeFormat = '%-7s'
            tmpTimeStr = \
                event['s'].strftime("%I:%M").lstrip('0').rjust(5) + \
                event['s'].strftime('%p').lower()

        if not prefix:
            prefix = indent

        PrintMsg(self.dateColor, prefix)
        if event['s'].hour == 0 and event['s'].minute == 0 and \
           event['e'].hour == 0 and event['e'].minute == 0:
            fmt = '  ' + timeFormat + '  %s\n'
            PrintMsg(self._CalendarColor(event['gcalcli_cal']), fmt %
                     ('', self._ValidTitle(event).strip()))
        else:
            fmt = '  ' + timeFormat + '  %s\n'
            if 'summary' not in event:
                dprint(event)
            PrintMsg(self._CalendarColor(event['gcalcli_cal']), fmt %
                     (tmpTimeStr, self._ValidTitle(event).strip()))

        if self.detailCalendar:
            xstr = "%s  Calendar: %s\n" % (
                detailsIndent,
                event['gcalcli_cal']['summary']
            )
            PrintMsg(CLR_NRM(), xstr)

        if self.detailUrl:
            hLink = self._ShortenURL(event['htmlLink'])
            xstr = "%s  Link: %s\n" % (detailsIndent, hLink)
            PrintMsg(CLR_NRM(), xstr)

        if self.detailLocation and \
           'location' in event and \
           event['location'].strip():
            xstr = "%s  Location: %s\n" % (
                detailsIndent,
                event['location'].strip()
            )
            PrintMsg(CLR_NRM(), xstr)

        if self.detailLength:
            diffDateTime = (event['e'] - event['s'])
            xstr = "%s  Length: %s\n" % (detailsIndent, diffDateTime)
            PrintMsg(CLR_NRM(), xstr)

        if self.detailReminders and 'reminders' in event:
            if event['reminders']['useDefault'] == True:
                xstr = "%s  Reminder: (default)\n" % (detailsIndent)
                PrintMsg(CLR_NRM(), xstr)
            elif 'overrides' in event['reminders']:
                for rem in event['reminders']['overrides']:
                    xstr = "%s  Reminder: %s %d minutes\n" % \
                           (detailsIndent, rem['method'], rem['minutes'])
                    PrintMsg(CLR_NRM(), xstr)

        if self.detailDescr and \
           'description' in event and \
           event['description'].strip():
            descrIndent = detailsIndent + '  '
            box = True # leave old non-box code for option later
            if box:
                topMarker = (descrIndent +
                             str(ART_ULC()) +
                             (str(ART_HRZ()) *
                              ((self.detailDescrWidth - len(descrIndent)) -
                               2)) +
                             str(ART_URC()))
                botMarker = (descrIndent +
                             str(ART_LLC()) +
                             (str(ART_HRZ()) *
                              ((self.detailDescrWidth - len(descrIndent)) -
                               2)) +
                             str(ART_LRC()))
                xstr = "%s  Description:\n%s\n%s\n%s\n" % (
                    detailsIndent,
                    topMarker,
                    _formatDescr(event['description'].strip(),
                                 descrIndent, box),
                    botMarker
                )
            else:
                marker = descrIndent + '-' * \
                         (self.detailDescrWidth - len(descrIndent))
                xstr = "%s  Description:\n%s\n%s\n%s\n" % (
                    detailsIndent,
                    marker,
                    _formatDescr(event['description'].strip(),
                                 descrIndent, box),
                    marker
                )
            PrintMsg(CLR_NRM(), xstr)


    def _DeleteEvent(self, event):

        if self.iamaExpert:
            self._CalService().events().\
                 delete(calendarId = event['gcalcli_cal']['id'],
                        eventId = event['id']).execute()
            PrintMsg(CLR_RED(), "Deleted!\n")
            return

        PrintMsg(CLR_MAG(), "Delete? [N]o [y]es [q]uit: ")
        val = raw_input()

        if not val or val.lower() == 'n':
            return

        elif val.lower() == 'y':
            self._CalService().events().\
                 delete(calendarId = event['gcalcli_cal']['id'],
                        eventId = event['id']).execute()
            PrintMsg(CLR_RED(), "Deleted!\n")

        elif val.lower() == 'q':
            sys.stdout.write('\n')
            sys.exit(0)

        else:
            PrintErrMsg('Error: invalid input\n')
            sys.stdout.write('\n')
            sys.exit(1)


    def _EditEvent(self, event):

        while True:

            PrintMsg(CLR_MAG(), "Edit?\n" +
                                "[N]o [s]ave [q]uit " +
                                "[t]itle [l]ocation " +
                                "[w]hen len[g]th " +
                                "[r]eminder [d]escr: ")
            val = raw_input()

            if not val or val.lower() == 'n':
                return

            elif val.lower() == 's':
                # copy only editable event details for patching
                modEvent = {}
                keys = ['summary', 'location', 'start', 'end',
                        'reminders', 'description']
                for k in keys:
                    if k in event:
                        modEvent[k] = event[k]

                self._CalService().events().\
                     patch(calendarId = event['gcalcli_cal']['id'],
                           eventId = event['id'],
                           body = modEvent).execute()
                PrintMsg(CLR_RED(), "Saved!\n")
                return

            elif not val or val.lower() == 'q':
                sys.stdout.write('\n')
                sys.exit(0)

            elif val.lower() == 't':
                PrintMsg(CLR_MAG(), "Title: ")
                val = raw_input()
                if val.strip():
                    event['summary'] = \
                        unicode(val.strip(), locale.getpreferredencoding())

            elif val.lower() == 'l':
                PrintMsg(CLR_MAG(), "Location: ")
                val = raw_input()
                if val.strip():
                    event['location'] = \
                        unicode(val.strip(), locale.getpreferredencoding())

            elif val.lower() == 'w':
                PrintMsg(CLR_MAG(), "When: ")
                val = raw_input()
                if val.strip():
                    td = (event['e'] - event['s'])
                    length = ((td.days * 1440) + (td.seconds / 60))
                    newStart, newEnd = GetTimeFromStr(val.strip(), length)
                    event['s'] = parse(newStart)
                    event['e'] = parse(newEnd)
                    event['start'] = \
                        { 'dateTime' : newStart,
                          'timeZone' : event['gcalcli_cal']['timeZone'] }
                    event['end'] = \
                        { 'dateTime' : newEnd,
                          'timeZone' : event['gcalcli_cal']['timeZone'] }

            elif val.lower() == 'g':
                PrintMsg(CLR_MAG(), "Length (mins): ")
                val = raw_input()
                if val.strip():
                    newStart, newEnd = \
                        GetTimeFromStr(event['start']['dateTime'], val.strip())
                    event['s'] = parse(newStart)
                    event['e'] = parse(newEnd)
                    event['start'] = \
                        { 'dateTime' : newStart,
                          'timeZone' : event['gcalcli_cal']['timeZone'] }
                    event['end'] = \
                        { 'dateTime' : newEnd,
                          'timeZone' : event['gcalcli_cal']['timeZone'] }

            elif val.lower() == 'r':
                PrintMsg(CLR_MAG(), "Reminder (mins): ")
                val = raw_input()
                if val.strip().isdigit():
                    event['reminders'] = \
                        {'useDefault' : False,
                         'overrides'  : [{'minutes' : int(val.strip()),
                                          'method'  : 'popup'}]}

            elif val.lower() == 'd':
                PrintMsg(CLR_MAG(), "Description: ")
                val = raw_input()
                if val.strip():
                    event['description'] = \
                        unicode(val.strip(), locale.getpreferredencoding())

            else:
                PrintErrMsg('Error: invalid input\n')
                sys.stdout.write('\n')
                sys.exit(1)

            self._PrintEvent(event, event['s'].strftime('\n%F'))


    def _IterateEvents(self, startDateTime, eventList,
                       yearDate=False, work=None):

        if len(eventList) == 0:
            PrintMsg(CLR_YLW(), "\nNo Events Found...\n")
            return

        # 10 chars for day and length must match 'indent' in _PrintEvent
        dayFormat = '\n%F' if yearDate else '\n%a %b %d'
        day = ''

        for event in eventList:

            if self.ignoreStarted and (event['s'] < startDateTime):
                continue

            tmpDayStr = event['s'].strftime(dayFormat)
            prefix    = None
            if yearDate or tmpDayStr != day:
                day = prefix = tmpDayStr

            self._PrintEvent(event, prefix)

            if work:
                work(event)


    def _GetAllEvents(self, cal, events, end):

        eventList = []

        while 1:
            if 'items' not in events:
                break

            for event in events['items']:

                event['gcalcli_cal'] = cal

                if 'status' in event and event['status'] == 'cancelled':
                    continue

                if 'dateTime' in event['start']:
                    event['s'] = parse(event['start']['dateTime'])
                else:
                    event['s'] = parse(event['start']['date']) # all date events

                if event['s'].tzinfo == None:
                    event['s'] = event['s'].replace(tzinfo=tzlocal())
                else:
                    event['s'] = event['s'].astimezone(tzlocal())

                if 'dateTime' in event['end']:
                    event['e'] = parse(event['end']['dateTime'])
                else:
                    event['e'] = parse(event['end']['date']) # all date events

                if event['e'].tzinfo == None:
                    event['e'] = event['e'].replace(tzinfo=tzlocal())
                else:
                    event['e'] = event['e'].astimezone(tzlocal())

                # For all-day events, Google seems to assume that the event time
                # is based in the UTC instead of the local timezone.  Here we
                # filter out those events start beyond a specified end time.
                if end and (event['s'] >= end):
                    continue

                # http://en.wikipedia.org/wiki/Year_2038_problem
                # Catch the year 2038 problem here as the python dateutil module
                # can choke throwing a ValueError exception. If either the start
                # or end time for an event has a year '>= 2038' dump it.
                if event['s'].year >= 2038 or event['e'].year >= 2038:
                    continue

                eventList.append(event)

            pageToken = events.get('nextPageToken')
            if pageToken:
                events = self._CalService().events().\
                         list(calendarId = cal['id'],
                              pageToken = pageToken).execute()
            else:
                break

        return eventList


    def _SearchForCalEvents(self, start, end, searchText):

        eventList = []

        queue = Queue()
        threads = []

        def worker(cal, work):
            events = work.execute()
            queue.put((cal, events))

        for cal in self.cals:

            work = self._CalService().events().\
                   list(calendarId = cal['id'],
                        timeMin = start.isoformat() if start else None,
                        timeMax = end.isoformat() if end else None,
                        q = searchText if searchText else None,
                        singleEvents = True)

            #th = threading.Thread(target=worker, args=(cal, work))
            #threads.append(th)
            #th.start()
            events = work.execute()
            queue.put((cal, events))

        #for th in threads:
        #    th.join()

        while not queue.empty():
            cal, events = queue.get()
            eventList.extend(self._GetAllEvents(cal, events, end))

        eventList.sort(lambda x, y: cmp(x['s'], y['s']))

        return eventList


    def ListAllCalendars(self):

        accessLen = 0

        for cal in self.allCals:
            length = len(cal['accessRole'])
            if length > accessLen: accessLen = length

        if accessLen < len('Access'): accessLen = len('Access')

        format = ' %0' + str(accessLen) + 's  %s\n'

        PrintMsg(CLR_BRYLW(), format % ('Access', 'Title'))
        PrintMsg(CLR_BRYLW(), format % ('------', '-----'))

        for cal in self.allCals:
            PrintMsg(self._CalendarColor(cal),
                     format % (cal['accessRole'], cal['summary']))


    def TextQuery(self, searchText=''):

        # the empty string would get *ALL* events...
        if searchText == '':
            return

        if self.ignoreStarted:
            start = self.now
        else:
            start = None

        eventList = self._SearchForCalEvents(start, None, searchText)

        self._IterateEvents(self.now, eventList, yearDate=True)


    def AgendaQuery(self, startText='', endText=''):
        if startText == '':
            if self.ignoreStarted:
                start = self.now
            else:
                # convert now to midnight this morning and use for default
                start = self.now.replace(hour=0,
                                         minute=0,
                                         second=0,
                                         microsecond=0)
        else:
            try:
                start = self.dateParser.fromString(startText, not self.ignoreStarted)
            except:
                PrintErrMsg('Error: failed to parse start time\n')
                return

        if endText == '':
            end = (start + timedelta(days=self.agendaLength))
        else:
            try:
                end = self.dateParser.fromString(endText, not self.ignoreStarted)
            except:
                PrintErrMsg('Error: failed to parse end time\n')
                return

        eventList = self._SearchForCalEvents(start, end, None)

        if self.tsv:
            self._tsv(start, eventList)
        else:
            self._IterateEvents(start, eventList, yearDate=False)


    def CalQuery(self, cmd, startText='', count=1):

        if startText == '':
            # convert now to midnight this morning and use for default
            start = self.now.replace(hour=0,
                                     minute=0,
                                     second=0,
                                     microsecond=0)
        else:
            try:
                start = self.dateParser.fromString(startText)
                start = start.replace(hour=0, minute=0, second=0, microsecond=0)
            except:
                PrintErrMsg('Error: failed to parse start time\n')
                return

        # convert start date to the beginning of the week or month
        if cmd == 'calw':
            dayNum = int(start.strftime("%w"))
            if self.calMonday:
                dayNum -= 1
                if dayNum < 0:
                    dayNum = 6
            start = (start - timedelta(days=dayNum))
            end = (start + timedelta(days=(count * 7)))
        else: # cmd == 'calm':
            start = (start - timedelta(days=(start.day - 1)))
            endMonth = (start.month + 1)
            endYear = start.year
            if endMonth == 13:
                endMonth = 1
                endYear += 1
            end = start.replace(month=endMonth, year=endYear)
            daysInMonth = (end - start).days
            offsetDays = int(start.strftime('%w'))
            if self.calMonday:
                offsetDays -= 1
                if offsetDays < 0:
                    offsetDays = 6
            totalDays = (daysInMonth + offsetDays)
            count = (totalDays / 7)
            if totalDays % 7:
                count += 1

        eventList = self._SearchForCalEvents(start, end, None)

        self._GraphEvents(cmd, start, count, eventList)


    def QuickAddEvent(self, eventText, reminder=None):

        if eventText == '':
            return

        if len(self.cals) != 1:
            PrintErrMsg("Must specify a single calendar\n")
            return

        newEvent = self._CalService().events().\
                   quickAdd(calendarId = self.cals[0]['id'],
                            text = eventText).execute()

        if reminder:
            rem = {}
            rem['reminders'] = {'useDefault' : False,
                                'overrides'  : [{'minutes' : reminder,
                                                 'method'  : 'popup'}]}

            newEvent = self._CalService().events().\
                       patch(calendarId = self.cals[0]['id'],
                             eventId = newEvent['id'],
                             body = rem).execute()

        if self.detailUrl:
            hLink = self._ShortenURL(newEvent['htmlLink'])
            PrintMsg(CLR_GRN(), 'New event added: %s\n' % hLink)


    def AddEvent(self, eTitle, eWhere, eStart, eEnd, eDescr, reminder):

        if len(self.cals) != 1:
            PrintErrMsg("Must specify a single calendar\n")
            return

        event = {}
        event['summary'] = eTitle
        event['start']   = { 'dateTime' : eStart,
                             'timeZone' : self.cals[0]['timeZone'] }
        event['end']     = { 'dateTime' : eEnd,
                             'timeZone' : self.cals[0]['timeZone'] }
        if eWhere:
            event['location'] = eWhere
        if eDescr:
            event['description'] = eDescr
        if reminder:
            event['reminders'] = {'useDefault' : False,
                                  'overrides'  : [{'minutes' : reminder,
                                                   'method'  : 'popup'}]}

        newEvent = self._CalService().events().\
                   insert(calendarId = self.cals[0]['id'],
                          body = event).execute()

        if self.detailUrl:
            hLink = self._ShortenURL(newEvent['htmlLink'])
            PrintMsg(CLR_GRN(), 'New event added: %s\n' % hLink)


    def DeleteEvents(self, searchText='', expert=False):

        # the empty string would get *ALL* events...
        if searchText == '':
            return

        eventList = self._SearchForCalEvents(None, None, searchText)

        self.iamaExpert = expert
        self._IterateEvents(self.now, eventList,
                            yearDate=True, work=self._DeleteEvent)


    def EditEvents(self, searchText=''):

        # the empty string would get *ALL* events...
        if searchText == '':
            return

        eventList = self._SearchForCalEvents(None, None, searchText)

        self._IterateEvents(self.now, eventList,
                            yearDate=True, work=self._EditEvent)


    def Remind(self, minutes=10, command=None):

        if command == None:
            command = self.command

        # perform a date query for now + minutes + slip
        start = self.now
        end   = (start + timedelta(minutes=(minutes + 5)))

        eventList = self._SearchForCalEvents(start, end, None)

        message = ''

        for event in eventList:

            # skip this event if it already started
            # XXX maybe add a 2+ minute grace period here...
            if event['s'] < self.now:
                continue

            if self.military:
                tmpTimeStr = event['s'].strftime('%H:%M')
            else:
                tmpTimeStr = \
                    event['s'].strftime('%I:%M').lstrip('0') + \
                    event['s'].strftime('%p').lower()

            message += '%s  %s\n' % \
                       (tmpTimeStr, self._ValidTitle(event).strip())

        if message == '':
            return

        cmd = shlex.split(command)

        for i, a in zip(xrange(len(cmd)), cmd):
            if a == '%s':
                cmd[i] = message

        pid = os.fork()
        if not pid:
            os.execvp(cmd[0], cmd)


    def ImportICS(self, verbose=False, reminder=None, icsFile=None):

        def CreateEventFromVOBJ(ve):

            event = {}

            if hasattr(ve, 'summary'):
                DebugPrint("SUMMARY: %s\n" % ve.summary.value)
                event['summary'] = ve.summary.value

            if hasattr(ve, 'location'):
                DebugPrint("LOCATION: %s\n" % ve.location.value)
                event['location'] = ve.location.value

            if not hasattr(ve, 'dtstart') or not hasattr(ve, 'dtend'):
                PrintErrMsg("Error: event does not have a dtstart and dtend!\n")
                return None

            DebugPrint("DTSTART: %s\n" % ve.dtstart.value.isoformat())
            DebugPrint("DTEND: %s\n" % ve.dtend.value.isoformat())

            if hasattr(ve, 'rrule'):
                DebugPrint("RRULE: %s\n" % ve.rrule.value)
                event['recurrence'] = [ "RRULE:" + ve.rrule.value ]

            if hasattr(ve, 'dtstart') and hasattr(ve, 'dtend'):

                start = ve.dtstart.value.isoformat()
                end   = ve.dtend.value.isoformat()

                # XXX
                # Timezone madness! Note that we're using the timezone for the
                # calendar being added to. This is OK if the event is in the
                # same timezone. This needs to be changed to use the timezone
                # from the DTSTART and DTEND values. Problem is, for example,
                # the TZID might be "Pacific Standard Time" and Google expects
                # a timezone string like "America/Los_Angeles". Need to find
                # a way in python to convert to the more specific timezone
                # string.
                # XXX
                # print ve.dtstart.params['X-VOBJ-ORIGINAL-TZID'][0]
                # print self.cals[0]['timeZone']
                # print dir(ve.dtstart.value.tzinfo)
                # print vars(ve.dtstart.value.tzinfo)

                event['start'] = { 'dateTime' : start,
                                   'timeZone' : self.cals[0]['timeZone'] }
                                   #'timeZone' : ve.dtstart.value.tzinfo._tzid }
                event['end']   = { 'dateTime' : end,
                                   'timeZone' : self.cals[0]['timeZone'] }
                                   #'timeZone' : ve.dtend.value.tzinfo._tzid }

                if reminder:
                    event['reminders'] = {'useDefault' : False,
                                          'overrides'  : [{'minutes' : reminder,
                                                           'method'  : 'popup'}]}

            if hasattr(ve, 'description') and ve.description.value.strip():
                descr = ve.description.value.strip()
                DebugPrint("DESCRIPTION: %s\n" % descr)
                event['description'] = descr

            if hasattr(ve, 'organizer'):
                DebugPrint("ORGANIZER: %s\n" % ve.organizer.value)

                if ve.organizer.value.startswith("MAILTO:"):
                    email = ve.organizer.value[7:]
                else:
                    email = ve.organizer.value

                event['organizer'] = { 'displayName' : ve.organizer.name,
                                       'email'       : email }

            if hasattr(ve, 'attendee_list'):
                DebugPrint("ATTENDEE_LIST : %s\n" % ve.attendee_list)
                event['attendees'] = []
                for attendee in ve.attendee_list:
                    if attendee.value.startswith("MAILTO:"):
                        email = attendee.value[7:]
                    else:
                        email = attendee.value

                    event['attendees'].append({ 'displayName' : attendee.name,
                                                'email'       : email })
            if verbose:
                PrintVobjEvent(ve);

            return event

        try:
            import vobject
        except:
            PrintErrMsg('Python vobject module not installed!\n')
            sys.exit(1)

        if len(self.cals) != 1:
            PrintErrMsg("Must specify a single calendar\n")
            return

        f = sys.stdin

        if icsFile:
            try:
                f = file(icsFile)
            except Exception, e:
                PrintErrMsg("Error: " + str(e) + "!\n")
                sys.exit(1)

        while True:

            try:
                v = vobject.readComponents(f).next()
            except StopIteration:
                break

            #v.prettyPrint()

            for ve in v.vevent_list:

                event = CreateEventFromVOBJ(ve)

                if not event:
                    continue

                if not verbose:
                    newEvent = self._CalService().events().\
                               insert(calendarId = self.cals[0]['id'],
                                      body = event).execute()
                    continue

                #dprint(event)
                PrintMsg(CLR_MAG(), "\n[S]kip [i]mport [q]uit: ")
                val = raw_input()
                if not val or val.lower() == 's':
                    continue
                if val.lower() == 'i':
                    newEvent = self._CalService().events().\
                               insert(calendarId = self.cals[0]['id'],
                                      body = event).execute()
                    hLink = self._ShortenURL(newEvent['htmlLink'])
                    PrintMsg(CLR_GRN(), 'New event added: %s\n' % hLink)
                elif val.lower() == 'q':
                    sys.exit(0)
                else:
                    PrintErrMsg('Error: invalid input\n')
                    sys.exit(1)


def LoadConfig(configFile):

    config = RawConfigParser()
    config.read(os.path.expanduser(configFile))
    return config


def GetConfig(config, key, default):

    try:
        value = config.get('gcalcli', key)
    except:
        value = default

    if value and value.startswith('`'):
        # execute shell command
        cmd = value.strip()[1:-1]
        value = subprocess.check_output(cmd, shell=True)

    return value


def GetConfigMultiple(config, key, default):

    try:
        values = config.get('gcalcli', key)
    except:
        values = default

    if values == None:
        return [ None ]

    valueList = csv.reader([ values ],
                           delimiter=',',
                           quotechar='"',
                           skipinitialspace=True).next()
    return valueList


def GetTrueFalse(value):

    if value.lower() == 'false': return False
    else: return True


def GetColor(value, exitFlag):

    colors = { 'default'       : CLR_NRM(),
               'black'         : CLR_BLK(),
               'brightblack'   : CLR_BRBLK(),
               'red'           : CLR_RED(),
               'brightred'     : CLR_BRRED(),
               'green'         : CLR_GRN(),
               'brightgreen'   : CLR_BRGRN(),
               'yellow'        : CLR_YLW(),
               'brightyellow'  : CLR_BRYLW(),
               'blue'          : CLR_BLU(),
               'brightblue'    : CLR_BRBLU(),
               'magenta'       : CLR_MAG(),
               'brightmagenta' : CLR_BRMAG(),
               'cyan'          : CLR_CYN(),
               'brightcyan'    : CLR_BRCYN(),
               'white'         : CLR_WHT(),
               'brightwhite'   : CLR_BRWHT() }

    try:
        return colors[value]
    except:
        if exitFlag:
            PrintErrMsg('Error: invalid color name\n')
            sys.exit(1)
        else:
            return None


def GetCalColors(calNames):
    calColors = {}
    for calName in calNames:
        calNameParts = calName.split("#")
        calNameSimple = calNameParts[0]
        calColor = calColors.get(calNameSimple)
        if len(calNameParts) > 0:
            calColorRaw = calNameParts[-1]
            calColorNew = GetColor(calColorRaw, False)
            if calColorNew is not None:
                calColor = calColorNew
        calColors[calNameSimple] = calColor
    return calColors


def BowChickaWowWow():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "",
                                   ["help",
                                    "version",
                                    "config=",
                                    "cals=",
                                    "cal=",
                                    "24hr",
                                    "detail-all",
                                    "detail-calendar",
                                    "detail-location",
                                    "detail-length",
                                    "detail-reminders",
                                    "detail-descr",
                                    "detail-descr-width=",
                                    "detail-url=",
                                    "tsv",
                                    "ignore-started",
                                    "width=",
                                    "mon",
                                    "nc",
                                    "nl",
                                    "conky",
                                    "cal-owner-color=",
                                    "cal-writer-color=",
                                    "cal-reader-color=",
                                    "cal-freebusy-color=",
                                    "date-color=",
                                    "now-marker-color=",
                                    "border-color=",
                                    "locale=",
                                    "reminder=",
                                    "title=",
                                    "where=",
                                    "when=",
                                    "duration=",
                                    "descr=",
                                    "iama-expert",
                                    "refresh",
                                    "no-cache"])
    except getopt.error:
        PrintErrMsg('Error: unknown argument\n')
        sys.exit(1)

    configFile = os.path.expanduser('~') + '/.gcalclirc'

    # look for config file override then load the config file
    # we do this first because command line args take precedence
    for opt, arg in opts:
        if opt == "--config": configFile = arg

    cfg = LoadConfig(configFile)

    calNames      = GetConfigMultiple(cfg, 'cal', None)
    military      = GetTrueFalse(GetConfig(cfg, '24hr', 'false'))
    ignoreStarted = GetTrueFalse(GetConfig(cfg, 'ignore-started', 'false'))
    calWidth      = int(GetConfig(cfg, 'width', '10'))
    calMonday     = GetTrueFalse(GetConfig(cfg, 'mon', 'false'))
    tsv           = GetTrueFalse(GetConfig(cfg, 'tsv', 'false'))
    customLocale  = GetConfig(cfg, 'locale', None)
    reminder      = GetConfig(cfg, 'reminder', None)

    detailAll        = GetTrueFalse(GetConfig(cfg, 'detail-all', 'false'))
    detailCalendar   = GetTrueFalse(GetConfig(cfg, 'detail-calendar', 'false'))
    detailLocation   = GetTrueFalse(GetConfig(cfg, 'detail-location', 'false'))
    detailLength     = GetTrueFalse(GetConfig(cfg, 'detail-length', 'false'))
    detailReminders  = GetTrueFalse(GetConfig(cfg, 'detail-reminders', 'false'))
    detailDescr      = GetTrueFalse(GetConfig(cfg, 'detail-descr', 'false'))
    detailDescrWidth = int(GetConfig(cfg, 'detail-descr-width', '80'))
    detailUrl        = GetConfig(cfg, 'detail-url', None)

    calOwnerColor = \
        GetColor(GetConfig(cfg, 'cal-owner-color', 'cyan'), True)
    calWriterColor = \
        GetColor(GetConfig(cfg, 'cal-writer-color', 'green'), True)
    calReaderColor = \
        GetColor(GetConfig(cfg, 'cal-reader-color', 'magenta'), True)
    calFreeBusyColor = \
        GetColor(GetConfig(cfg, 'cal-freebusy-color', 'default'), True)
    dateColor = \
        GetColor(GetConfig(cfg, 'date-color', 'yellow'), True)
    nowMarkerColor = \
        GetColor(GetConfig(cfg, 'now-marker-color', 'brightred'), True)
    borderColor = \
        GetColor(GetConfig(cfg, 'border-color', 'white'), True)

    eTitle    = None
    eWhere    = None
    eWhen     = None
    eDuration = None
    eDescr    = None

    # these options do not need to be in the config file
    iamaExpert   = False
    refreshCache = False
    useCache     = True

    # fix wokCalNames when not specified in config file
    if len(calNames) == 1 and calNames[0] == None:
        calNames      = []
        calNameColors = []

    calNamesCommandLine = []

    # Process options
    for opt, arg in opts:

        if opt == "--help":
            Usage()

        elif opt == "--version":
            Version()

        elif opt == "--cal":
            calNames.append(arg)
            calNamesCommandLine.append(arg)

        elif opt == "--24hr":
            military = True

        elif opt == "--detail-all":
            detailCalendar  = True
            detailLocation  = True
            detailLength    = True
            detailReminders = True
            detailDescr     = True
            if detailUrl != "short":
                detailUrl = "long"

        elif opt == "--detail-calendar":
            detailCalendar = True

        elif opt == "--detail-location":
            detailLocation = True

        elif opt == "--detail-length":
            detailLength = True

        elif opt == "--detail-reminders":
            detailReminders = True

        elif opt == "--detail-descr":
            detailDescr = True

        elif opt == "--detail-descr-width":
            detailDescrWidth = int(arg)

        elif opt == "--detail-url":
            detailUrl = arg

        elif opt == "--ignore-started":
            ignoreStarted = True

        elif opt == "--width":
            calWidth = int(arg)

        elif opt == "--mon":
            calMonday = True

        elif opt == "--nc":
            CLR.useColor = False

        elif opt == "--nl":
            ART.useArt = False

        elif opt == "--conky":
            SetConkyColors()

        elif opt == "--cal-owner-color":
            calOwnerColor = GetColor(arg, True)

        elif opt == "--cal-writer-color":
            calWriterColor = GetColor(arg, True)

        elif opt == "--cal-reader-color":
            calReaderColor = GetColor(arg, True)

        elif opt == "--cal-freebusy-color":
            calFreeBusyColor = GetColor(arg, True)

        elif opt == "--date-color":
            dateColor = GetColor(arg, True)

        elif opt == "--now-marker-color":
            nowMarkerColor = GetColor(arg, True)

        elif opt == "--border-color":
            borderColor = GetColor(arg, True)

        elif opt == "--tsv":
            tsv = True

        elif opt == "--locale":
            customLocale = arg

        elif opt == "--reminder":
            reminder = arg

        elif (opt == "--title"):
            eTitle = arg

        elif (opt == "--where"):
            eWhere = arg

        elif (opt == "--when"):
            eWhen = arg

        elif (opt == "--duration"):
            eDuration = arg

        elif (opt == "--descr"):
            eDescr = arg

        elif (opt == "--iama-expert"):
            iamaExpert = True

        elif (opt == "--refresh"):
            refreshCache = True

        elif (opt == "--no-cache"):
            useCache = False

    if detailUrl and detailUrl != 'short' and detailUrl != 'long':
        PrintErrMsg('Error: invalid detail url\n')
        sys.exit(1)

    if len(args) == 0:
        PrintErrMsg('Error: no command\n')
        sys.exit(1)

    if args[0] == 'import':
        if len(args) >= 2 and args[1] == "-d":
            if len(args) == 3: # ics file
                DumpICS(args[2])
                sys.exit(0)
            else:
                PrintErrMsg('Error: invalid import arguments\n')
                sys.exit(1)

    calColors = GetCalColors(calNames)
    if len(calNamesCommandLine) > 0:
        calNames = calNamesCommandLine

    calNamesFiltered = []
    calNameColors = []
    for calName in calNames:
        calNameSimple = calName.split("#")[0]
        calNamesFiltered.append(calNameSimple)
        calNameColors.append(calColors[calNameSimple])
    calNames = calNamesFiltered

    gcal = gcalcli(calNames=calNames,
                   calNameColors=calNameColors,
                   military=military,
                   detailCalendar=detailCalendar,
                   detailLocation=detailLocation,
                   detailLength=detailLength,
                   detailReminders=detailReminders,
                   detailDescr=detailDescr,
                   detailDescrWidth=detailDescrWidth,
                   detailUrl=detailUrl,
                   ignoreStarted=ignoreStarted,
                   calWidth=calWidth,
                   calMonday=calMonday,
                   calOwnerColor=calOwnerColor,
                   calWriterColor=calWriterColor,
                   calReaderColor=calReaderColor,
                   calFreeBusyColor=calFreeBusyColor,
                   dateColor=dateColor,
                   nowMarkerColor=nowMarkerColor,
                   borderColor=borderColor,
                   tsv=tsv,
                   customLocale=customLocale,
                   refreshCache=refreshCache,
                   useCache=useCache)

    if args[0] == 'list':
        gcal.ListAllCalendars()

    elif args[0] == 'search':
        if len(args) != 2:
            PrintErrMsg('Error: invalid search string\n')
            sys.exit(1)

        # allow unicode strings for input
        gcal.TextQuery(unicode(args[1], locale.getpreferredencoding()))

        sys.stdout.write('\n')

    elif args[0] == 'agenda':
        if len(args) == 3: # start and end
            gcal.AgendaQuery(startText=args[1], endText=args[2])
        elif len(args) == 2: # start
            gcal.AgendaQuery(startText=args[1])
        elif len(args) == 1: # defaults
            gcal.AgendaQuery()
        else:
            PrintErrMsg('Error: invalid agenda arguments\n')
            sys.exit(1)

        if not tsv:
            sys.stdout.write('\n')

    elif args[0] == 'calw':
        if not calWidth:
            PrintErrMsg('Error: invalid width, don\'t be an idiot!\n')
            sys.exit(1)

        if len(args) >= 2:
            try:
                count = int(args[1])
            except:
                PrintErrMsg('Error: invalid calw arguments\n')
                sys.exit(1)

        if len(args) == 3: # weeks and start
            gcal.CalQuery(args[0], count=int(args[1]), startText=args[2])
        elif len(args) == 2: # weeks
            gcal.CalQuery(args[0], count=int(args[1]))
        elif len(args) == 1: # defaults
            gcal.CalQuery(args[0])
        else:
            PrintErrMsg('Error: invalid calw arguments\n')
            sys.exit(1)

        sys.stdout.write('\n')

    elif args[0] == 'calm':
        if not calWidth:
            PrintErrMsg('Error: invalid width, don\'t be an idiot!\n')
            sys.exit(1)

        if len(args) == 2: # start
            gcal.CalQuery(args[0], startText=args[1])
        elif len(args) == 1: # defaults
            gcal.CalQuery(args[0])
        else:
            PrintErrMsg('Error: invalid calm arguments\n')
            sys.exit(1)

        sys.stdout.write('\n')

    elif args[0] == 'quick':
        if len(args) != 2:
            PrintErrMsg('Error: invalid event text\n')
            sys.exit(1)

        # allow unicode strings for input
        gcal.QuickAddEvent(unicode(args[1], locale.getpreferredencoding()),
                           reminder=reminder)

    elif (args[0] == 'add'):
        if eTitle == None:
            PrintMsg(CLR_MAG(), "Title: ")
            eTitle = raw_input()
        if eWhere == None:
            PrintMsg(CLR_MAG(), "Location: ")
            eWhere = raw_input()
        if eWhen == None:
            PrintMsg(CLR_MAG(), "When: ")
            eWhen = raw_input()
        if eDuration == None:
            PrintMsg(CLR_MAG(), "Duration (mins): ")
            eDuration = raw_input()
        if eDescr == None:
            PrintMsg(CLR_MAG(), "Description: ")
            eDescr = raw_input()
        if reminder == None:
            PrintMsg(CLR_MAG(), "Reminder (mins): ")
            reminder = raw_input()

        # calculate "when" time:
        eStart, eEnd = GetTimeFromStr(eWhen, eDuration)

        # allow unicode strings for input
        ueTitle = unicode(eTitle, locale.getpreferredencoding())
        ueWhere = unicode(eWhere, locale.getpreferredencoding())
        ueStart = unicode(eStart, locale.getpreferredencoding())
        ueEnd   = unicode(eEnd,   locale.getpreferredencoding())
        ueDescr = unicode(eDescr, locale.getpreferredencoding())

        gcal.AddEvent(ueTitle, ueWhere, ueStart, ueEnd, ueDescr, reminder)

    elif args[0] == 'delete':
        if len(args) != 2:
            PrintErrMsg('Error: invalid search string\n')
            sys.exit(1)

        # allow unicode strings for input
        gcal.DeleteEvents(unicode(args[1], locale.getpreferredencoding()),
                          iamaExpert)

        sys.stdout.write('\n')

    elif args[0] == 'edit':
        if len(args) != 2:
            PrintErrMsg('Error: invalid search string\n')
            sys.exit(1)

        # allow unicode strings for input
        gcal.EditEvents(unicode(args[1], locale.getpreferredencoding()))

        sys.stdout.write('\n')

    elif args[0] == 'remind':
        if len(args) == 3: # minutes and command
            gcal.Remind(int(args[1]), args[2])
        elif len(args) == 2: # minutes
            gcal.Remind(int(args[1]))
        elif len(args) == 1: # defaults
            gcal.Remind()
        else:
            PrintErrMsg('Error: invalid remind arguments\n')
            sys.exit(1)

    elif args[0] == 'import':
        args = args[1:]
        verbose = False
        if len(args) >= 1 and args[0] == "-v":
            verbose = True
            args = args[1:]
        if len(args) == 0: # stdin
            gcal.ImportICS(verbose, reminder)
        elif len(args) == 1: # ics file
            gcal.ImportICS(verbose, reminder, args[0])
        else:
            PrintErrMsg('Error: invalid import arguments\n')
            sys.exit(1)

    elif args[0] == 'help':
        Usage()

    else:
        PrintErrMsg('Error: unknown command\n')
        sys.exit(1)


def SIGINT_handler(signum, frame):
    PrintErrMsg('Signal caught, bye!\n')
    sys.exit(1)

signal.signal(signal.SIGINT, SIGINT_handler)

if __name__ == '__main__':
    BowChickaWowWow()

