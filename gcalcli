#!/usr/bin/env python

# ** The MIT License **
#
# Copyright (c) 2007 Eric Davis (aka Insanum)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Dude... just buy us a beer. :-)
#

#############################################################################
#                                                                           #
#                                      (           (     (                  #
#               (         (     (      )\ )   (    )\ )  )\ )               #
#               )\ )      )\    )\    (()/(   )\  (()/( (()/(               #
#              (()/(    (((_)((((_)(   /(_))(((_)  /(_)) /(_))              #
#               /(_))_  )\___ )\ _ )\ (_))  )\___ (_))  (_))                #
#              (_)) __|((/ __|(_)_\(_)| |  ((/ __|| |   |_ _|               #
#                | (_ | | (__  / _ \  | |__ | (__ | |__  | |                #
#                 \___|  \___|/_/ \_\ |____| \___||____||___|               #
#                                                                           #
# Author: Eric Davis <http://www.insanum.com>                               #
#         Brian Hartvigsen <http://github.com/tresni>                       #
# Home: http://code.google.com/p/gcalcli                                    #
#                                                                           #
# Requirements:                                                             #
#  - Python 2                                                               #
#        http://www.python.org                                              #
#  - Google's GData Python module (for Python 2)                            #
#        http://code.google.com/p/gdata-python-client                       #
#  - dateutil Python module                                                 #
#        http://www.labix.org/python-dateutil                               #
#                                                                           #
# Optional:                                                                 #
#  - vobject Python module (needed for importing ics/vcal files)            #
#        http://vobject.skyhouseconsulting.com                              #
#  - simplejson Python module (needed for url shortening)                    #
#        https://github.com/simplejson/simplejson                           #
#  - parsedatetime Python module (needed for fuzzy date parsing)            #
#        https://github.com/bear/parsedatetime                              #
#                                                                           #
#############################################################################

__program__         = 'gcalcli'
__version__         = 'v2.4'
__author__          = 'Eric Davis, Brian Hartvigsen'
__gcalcli_api_key__ = 'AIzaSyA6qJCdEnUiOX7Y79Ro5eA2toInxwWCikc'

import inspect

try:
    import sys, os, re, urllib, getopt, shlex, subprocess, time
    import codecs, locale, csv, threading, getpass, textwrap
    from Queue import Queue
    from ConfigParser import RawConfigParser
    from gdata.calendar.service import *
    from datetime import datetime, timedelta, date
    from dateutil.tz import *
    from dateutil.parser import *
    from dateutil.rrule import *
    from unicodedata import east_asian_width
except ImportError, e:
    print "ERROR: Missing module - %s" % e.args[0]
    sys.exit(1)

try:
    # If they have parsedatetime, we'll use it for fuzzy datetime comparison
    from parsedatetime import parsedatetime
except:
    class parsedatetime:
        class Calendar:
            def parse(self, string):
                return ([], 0)

def Version():
    sys.stdout.write(__program__+' '+__version__+' ('+__author__+')\n')
    sys.exit(1)


def Usage():
    sys.stdout.write('''
Usage:

gcalcli [options] command [command args]

 Options:

  --help                   this usage text

  --version                version information

  --config <file>          config file to read (default is '~/.gcalclirc')

  --user <username>        google username

  --pw <password>          password

  --cals [all,             'calendars' to work with (default is all calendars)
          default,         - default (your default main calendar)
          owner,           - owner (your owned calendars)
          editor,          - editor (editable calendar)
          contributor,     - contributor (non-owner but able to edit)
          read,            - read (read only calendars)
          freebusy]        - freebusy (only free/busy info visible)

  --cal <name>[#color]     'calendar' to work with (default is all calendars)
                           - you can specify a calendar by name or by substring
                             which can match multiple calendars
                           - you can use multiple '--cal' arguments on the
                             command line
                           - in the config file specify multiple calendars in
                             quotes separated by commas as:
                               cal: "foo", "bar", "my cal"
                           - an optional color override can be specified per
                             calendar using the ending hashtag:
                               --cal "Eric Davis"#green --cal foo#red
                             or via the config file:
                               cal: "foo"#red, "bar"#yellow, "my cal"#green

  --24hr                   show all dates in 24 hour format

  --detail-all             show event details in the 'agenda' output
  --detail-location        - the description width defaults to 80 characters
  --detail-length          - if 'short' is specified for the url then the event
  --detail-reminders         link is shortened using http://goo.gl (slow!)
  --detail-descr
  --detail-descr-width
  --detail-url [short,
                long]

  --ignore-started         ignore old or already started events
                           - when used with the 'agenda' command, ignore events
                             that have already started and are in-progress with
                             respect to the specified [start] time
                           - when used with the 'search' command, ignore events
                             that have already occurred and only show future
                             events

  --width                  the number of characters to use for each column in
                           the 'calw' and 'calm' command outputs (default is 10)

  --mon                    week begins with Monday for 'calw' and 'calm' command
                           outputs (default is Sunday)

  --nc                     don't use colors

  --conky                  use conky color escapes sequences instead of ansi
                           terminal color escape sequences (requires using
                           the 'execpi' command in your conkyrc)

  --cal-owner-color        specify the colors used for the calendars and dates
  --cal-editor-color       each of these argument requires a <color> argument
  --cal-contributor-color  which must be one of [ default, black, brightblack,
  --cal-read-color         red, brightred, green, brightgreen, yellow,
  --cal-freebusy-color     brightyellow, blue, brightblue, magenta,
  --date-color             brightmagenta, cyan, brightcyan, white,
  --border-color           brightwhite ]

  --tsv                    tab-separated output for 'agenda'. Format is:
                           date, start, end, link, title, location, description

  --locale <locale>        set a custom locale (i.e. 'de_DE.UTF-8'). Check the
                           supported locales of your system first.

  --reminder <mins>        number of minutes to use when setting reminders for
                           the 'quick' and 'add' commands; if not specified,
                           Google code's default behavior occurs: no reminder is
                           set (documented, incorrectly, otherwise: as using the
                           default for the calendar, but this does not actually
                           happen)

   --title <title>         event details used by the 'add' command
   --where <location>      - the duration is specified in minutes
   --when <datetime>       - make sure to quote strings with spaces
   --duration <#>          - the datetime format is 'MM/DD/YYYY HH:MM'
   --descr <description>   - the '--reminder' option can be specified as well

 Commands:

  list                     list all calendars

  search <text>            search for events
                           - only matches whole words

  agenda [start] [end]     get an agenda for a time period
                           - start time default is 12am today
                           - end time default is 5 days from start
                           - example time strings:
                              '9/24/2007'
                              '24/09/2007'
                              '24/9/07'
                              'Sep 24 2007 3:30pm'
                              '2007-09-24T15:30'
                              '2007-09-24T15:30-8:00'
                              '20070924T15'
                              '8am'

  calw <weeks> [start]     get a week based agenda in a nice calendar format
                           - weeks is the number of weeks to display
                           - start time default is beginning of this week
                           - note that all events for the week(s) are displayed

  calm [start]             get a month agenda in a nice calendar format
                           - start time default is the beginning of this month
                           - note that all events for the month are displayed
                             and only one month will be displayed

  quick <text>             quick add an event to a calendar
                           - if a --cal is not specified then the event is
                             added to the default calendar
                           - example:
                              'Dinner with Eric 7pm tomorrow'
                              '5pm 10/31 Trick or Treat'

  add                      add a detailed event to a calendar
                           - if a --cal is not specified then the event is
                             added to the default calendar
                           - example:
                              gcalcli --title 'Analysis of Algorithms Final'
                                      --where UCI
                                      --when '12/14/2012 10:00'
                                      --duration 60
                                      --descr 'It is going to be hard!'
                                      --reminder 30
                                      add

  import [-v] [file]       import an ics/vcal file to a calendar
                           - if a --cal is not specified then the event is
                             added to the default calendar
                           - if a file is not specified then the data is read
                             from standard input
                           - if -v is given then each event in the file is
                             displayed and you're given the option to import
                             or skip it, by default everything is imported
                             quietly without any interaction

  remind <mins> <command>  execute command if event occurs within <mins>
                           minutes time ('%s' in <command> is replaced with
                           event start time and title text)
                           - <mins> default is 10
                           - default command:
                              'notify-send -u critical -a gcalcli %s'

''')
    sys.exit(1)


class CLR:

    useColor = True
    conky    = False

    def __str__(self):
        if self.useColor: return self.color
        else: return ""

class CLR_NRM(CLR):   color = "\033[0m"
class CLR_BLK(CLR):   color = "\033[0;30m"
class CLR_BRBLK(CLR): color = "\033[30;1m"
class CLR_RED(CLR):   color = "\033[0;31m"
class CLR_BRRED(CLR): color = "\033[31;1m"
class CLR_GRN(CLR):   color = "\033[0;32m"
class CLR_BRGRN(CLR): color = "\033[32;1m"
class CLR_YLW(CLR):   color = "\033[0;33m"
class CLR_BRYLW(CLR): color = "\033[33;1m"
class CLR_BLU(CLR):   color = "\033[0;34m"
class CLR_BRBLU(CLR): color = "\033[34;1m"
class CLR_MAG(CLR):   color = "\033[0;35m"
class CLR_BRMAG(CLR): color = "\033[35;1m"
class CLR_CYN(CLR):   color = "\033[0;36m"
class CLR_BRCYN(CLR): color = "\033[36;1m"
class CLR_WHT(CLR):   color = "\033[0;37m"
class CLR_BRWHT(CLR): color = "\033[37;1m"


def SetConkyColors():
    # XXX these colors should be configurable
    CLR.conky       = True
    CLR_NRM.color   = ""
    CLR_BLK.color   = "${color black}"
    CLR_BRBLK.color = "${color black}"
    CLR_RED.color   = "${color red}"
    CLR_BRRED.color = "${color red}"
    CLR_GRN.color   = "${color green}"
    CLR_BRGRN.color = "${color green}"
    CLR_YLW.color   = "${color yellow}"
    CLR_BRYLW.color = "${color yellow}"
    CLR_BLU.color   = "${color blue}"
    CLR_BRBLU.color = "${color blue}"
    CLR_MAG.color   = "${color magenta}"
    CLR_BRMAG.color = "${color magenta}"
    CLR_CYN.color   = "${color cyan}"
    CLR_BRCYN.color = "${color cyan}"
    CLR_WHT.color   = "${color white}"
    CLR_BRWHT.color = "${color white}"


def PrintErrMsg(msg):
    if CLR.useColor:
        sys.stdout.write(str(CLR_BRRED()))
        sys.stdout.write(msg)
        sys.stdout.write(str(CLR_NRM()))
    else:
        sys.stdout.write(msg)


def PrintMsg(color, msg):
    if CLR.useColor:
        sys.stdout.write(str(color))
        sys.stdout.write(msg)
        sys.stdout.write(str(CLR_NRM()))
    else:
        sys.stdout.write(msg)


def DebugPrint(msg):
    return
    sys.stdout.write(str(CLR_YLW()))
    sys.stdout.write(msg)
    sys.stdout.write(str(CLR_NRM()))


class DateTimeParser:
    def __init__(self):
        self.pdtCalendar = parsedatetime.Calendar();

    def fromString(self, eWhen, useMidnight=True):
        if useMidnight:
            defaultDateTime = datetime.now(tzlocal()).replace(hour=0,
                                                     minute=0,
                                                     second=0,
                                                     microsecond=0)
        else:
            defaultDateTime = datetime.now(tzlocal())

        try:
            eTimeStart = parse(eWhen, default=defaultDateTime)
        except:
            struct, result = self.pdtCalendar.parse(eWhen)
            eTimeStart = datetime.fromtimestamp(time.mktime(struct), tzlocal())
            if not result:
                raise ValueError("Date and time is invalid")


        return eTimeStart

def GetTimeFromStr(eWhen, eDuration=0):
    dtp = DateTimeParser()

    try:
        eTimeStart = dtp.fromString(eWhen)
    except:
        PrintErrMsg('Date and time is invalid!\n')
        sys.exit(1)

    try:
        eTimeStop = eTimeStart + timedelta(minutes=float(eDuration))
    except:
        PrintErrMsg('Duration time (minutes) is invalid\n')
        sys.exit(1)

    sTimeStart = eTimeStart.isoformat()
    sTimeStop = eTimeStop.isoformat()

    return sTimeStart, sTimeStop


def ShortenURL(url):
    from urllib2 import urlopen, Request
    try:
        import simplejson as json
    except ImportError:
        import json
    gshort  = 'https://www.googleapis.com/urlshortener/v1/url'
    data    = {"longUrl":url, "key":__gcalcli_api_key__}
    headers = {'Content-Type':'application/json', 'User-Agent':'gcalcli'}
    r = urlopen(Request(gshort, json.dumps(data), headers))
    j = json.loads(r.read())
    return j['id'] if 'id' in j else url


class gcalcli:

    gcal          = None
    allCals       = None
    cals          = []
    now           = datetime.now(tzlocal())
    feedPrefix    = 'https://www.google.com/calendar/feeds/'
    agendaLength  = 5
    username      = None
    password      = None
    access        = ''
    military      = False
    ignoreStarted = False
    calWidth      = 10
    calMonday     = False
    command       = 'notify-send -u critical -a gcalcli %s'
    tsv           = False
    customLocale  = None
    dateParser    = DateTimeParser()

    detailLocation   = False
    detailLength     = False
    detailReminders  = False
    detailDescr      = False
    detailDescrWidth = 80
    detailUrl        = None

    calOwnerColor       = CLR_CYN()
    calEditorColor      = CLR_NRM()
    calContributorColor = CLR_NRM()
    calReadColor        = CLR_MAG()
    calFreeBusyColor    = CLR_NRM()
    dateColor           = CLR_YLW()
    borderColor         = CLR_WHT()

    ACCESS_ALL         = 'all'      # non-google access level
    ACCESS_DEFAULT     = 'default'  # non-google access level
    ACCESS_CONTRIBUTOR = 'contributor'
    ACCESS_EDITOR      = 'editor'
    ACCESS_FREEBUSY    = 'freebusy'
    ACCESS_NONE        = 'none'
    ACCESS_OVERRIDE    = 'override'
    ACCESS_OWNER       = 'owner'
    ACCESS_READ        = 'read'
    ACCESS_RESPOND     = 'respond'
    ACCESS_ROOT        = 'root'


    def __init__(self,
                 username=None,
                 password=None,
                 access='all',
                 calNames=[],
                 calNameColors=[],
                 military=False,
                 detailLocation=False,
                 detailLength=False,
                 detailReminders=False,
                 detailDescr=False,
                 detailDescrWidth=80,
                 detailUrl=None,
                 ignoreStarted=False,
                 calWidth=10,
                 calMonday=False,
                 calOwnerColor=CLR_CYN(),
                 calEditorColor=CLR_GRN(),
                 calContributorColor=CLR_NRM(),
                 calReadColor=CLR_MAG(),
                 calFreeBusyColor=CLR_NRM(),
                 dateColor=CLR_GRN(),
                 borderColor=CLR_WHT(),
                 tsv=False,
                 customLocale=None):

        self.gcal          = CalendarService()
        self.gcal.ssl      = True

        self.username      = username
        self.password      = password

        self.access        = access
        self.military      = military
        self.ignoreStarted = ignoreStarted
        self.calWidth      = calWidth
        self.calMonday     = calMonday
        self.tsv           = tsv
        self.customLocale  = customLocale

        self.detailLocation   = detailLocation
        self.detailLength     = detailLength
        self.detailReminders  = detailReminders
        self.detailDescr      = detailDescr
        self.detailDescrWidth = detailDescrWidth
        self.detailUrl        = detailUrl

        self.calOwnerColor       = calOwnerColor
        self.calEditorColor      = calEditorColor
        self.calContributorColor = calContributorColor
        self.calReadColor        = calReadColor
        self.calFreeBusyColor    = calFreeBusyColor
        self.dateColor           = dateColor
        self.borderColor         = borderColor

        # set customLocale if correct
        try:
            locale.setlocale(locale.LC_ALL, customLocale)
        except Exception, e:
            PrintErrMsg("Error: " + str(e) + "!\n" +
                        "Check supported locales of your system.\n")
            sys.exit(1)

        # authenticate and login to google calendar
        try:
            self.gcal.ClientLogin(
                            username=self.username,
                            password=self.password,
                            service='cl',
                            source=__author__+'-'+__program__+'-'+__version__)
        except Exception, e:
            PrintErrMsg("Error: " + str(e) + "!\n")
            sys.exit(1)

        # get the list of calendars
        self.allCals = self.gcal.GetAllCalendarsFeed()

        # gcalcli defined way to order calendars XXX
        order = { self.ACCESS_OWNER       : 1,
                  self.ACCESS_EDITOR      : 2,
                  self.ACCESS_ROOT        : 3,
                  self.ACCESS_CONTRIBUTOR : 4,
                  self.ACCESS_OVERRIDE    : 5,
                  self.ACCESS_RESPOND     : 6,
                  self.ACCESS_FREEBUSY    : 7,
                  self.ACCESS_READ        : 8,
                  self.ACCESS_NONE        : 9 }

        self.allCals.entry.sort(lambda x, y:
                                cmp(order[x.access_level.value],
                                    order[y.access_level.value]))

        for cal in self.allCals.entry:

            cal.gcalcli_altLink = cal.GetAlternateLink().href

            match = re.match('^' + self.feedPrefix + '(.*?)/(.*?)/(.*)$',
                             cal.gcalcli_altLink)
            cal.gcalcli_username   = urllib.unquote(match.group(1))
            cal.gcalcli_visibility = urllib.unquote(match.group(2))
            cal.gcalcli_projection = urllib.unquote(match.group(3))

            if len(calNames):
                for i in xrange(len(calNames)):
                    if re.search(calNames[i].lower(),
                                 cal.title.text.lower()):
                        self.cals.append(cal)
                        cal.colorSpec = calNameColors[i]
            else:
                self.cals.append(cal)
                cal.colorSpec = None


    def _CalendarWithinAccess(self, cal):

        if self.access == self.ACCESS_ALL:
            return True
        elif self.access == self.ACCESS_DEFAULT and \
             cal.gcalcli_username == self.username:
            return True
        elif self.access != cal.access_level.value:
            return False
        else:
            return True


    def _CalendarColor(self, cal):

        if cal == None:
            return CLR_NRM()
        elif hasattr(cal, 'colorSpec') and cal.colorSpec != None:
            return cal.colorSpec
        elif cal.access_level.value == self.ACCESS_OWNER:
            return self.calOwnerColor
        elif cal.access_level.value == self.ACCESS_EDITOR:
            return self.calEditorColor
        elif cal.access_level.value == self.ACCESS_CONTRIBUTOR:
            return self.calContributorColor
        elif cal.access_level.value == self.ACCESS_FREEBUSY:
            return self.calFreeBusyColor
        elif cal.access_level.value == self.ACCESS_READ:
            return self.calReadColor
        else:
            return CLR_NRM()


    def _TargetCalendar(self):

        if len(self.cals) == 1:
            match = re.match('^https://www.google.com(.*)$',
                             self.cals[0].gcalcli_altLink)
            return match.group(1)
        else:
            return '/calendar/feeds/default/private/full'


    def _ValidTitle(self, title):
        if title == None:
            return "(No title)"
        else:
            return title


    def _GetWeekEventStrings(self, cmd, curMonth,
                             startDateTime, endDateTime, eventList):

        weekEventStrings = [ '', '', '', '', '', '', '' ]

        for event in eventList:

            if cmd == 'calm' and curMonth != event.s.strftime("%b"):
                continue

            dayNum = int(event.s.strftime("%w"))
            if self.calMonday:
                dayNum -= 1
                if dayNum < 0:
                    dayNum = 6

            if event.s >= startDateTime and event.s < endDateTime:

                if event.s.hour == 0 and event.s.minute == 0 and \
                   event.e.hour == 0 and event.e.minute == 0:
                    tmpTimeStr = ''
                elif self.military:
                    tmpTimeStr = event.s.strftime("%H:%M")
                else:
                    tmpTimeStr = \
                        event.s.strftime("%I:%M").lstrip('0') + \
                        event.s.strftime('%p').lower()

                # newline and empty string are the keys to turn off coloring
                weekEventStrings[dayNum] += \
                    "\n" + \
                    str(self._CalendarColor(event.gcalcli_cal)) + \
                    tmpTimeStr.strip() + \
                    " " + \
                    self._ValidTitle(event.title.text).strip()

        return weekEventStrings


    UNIWIDTH = {'W': 2, 'F': 2, 'N': 1, 'Na': 1, 'H': 1, 'A': 1}


    def _PrintLen(self, string):
        printLen = 0
        for tmpChar in string:
            printLen += self.UNIWIDTH[east_asian_width(tmpChar)]
        return printLen


    # return print length before cut, cut index, and force cut flag
    def _NextCut(self, string, curPrintLen):
        idx = 0
        printLen = 0
        for tmpChar in string:
            if (curPrintLen + printLen) >= self.calWidth:
                return (printLen, idx, True)
            if tmpChar in (' ', '\n'):
                return (printLen, idx, False)
            idx += 1
            printLen += self.UNIWIDTH[east_asian_width(tmpChar)]
        return (printLen, -1, False)


    def _GetCutIndex(self, eventString):

        printLen = self._PrintLen(eventString)

        if printLen <= self.calWidth:
            DebugPrint("------ printLen=%d (end of string)\n" % printLen)
            return (printLen, len(eventString))

        cutWidth, cut, forceCut = self._NextCut(eventString, 0)
        DebugPrint("------ cutWidth=%d cut=%d \"%s\"\n" %
                   (cutWidth, cut, eventString))

        if forceCut:
            DebugPrint("--- forceCut cutWidth=%d cut=%d\n" % (cutWidth, cut))
            return (cutWidth, cut)

        DebugPrint("--- looping\n")

        while cutWidth < self.calWidth:

            DebugPrint("--- cutWidth=%d cut=%d \"%s\"\n" %
                       (cutWidth, cut, eventString[cut:]))

            while cut < self.calWidth and \
                  cut < printLen and \
                  eventString[cut] == ' ':
                DebugPrint("-> skipping space <-\n")
                cutWidth += 1
                cut += 1

            DebugPrint("--- cutWidth=%d cut=%d \"%s\"\n" %
                       (cutWidth, cut, eventString[cut:]))

            nextCutWidth, nextCut, forceCut = \
                self._NextCut(eventString[cut:], cutWidth)

            if forceCut:
                DebugPrint("--- forceCut cutWidth=%d cut=%d\n" % (cutWidth, cut))
                break

            cutWidth += nextCutWidth
            cut += nextCut

            if eventString[cut] == '\n':
                break

            DebugPrint("--- loop cutWidth=%d cut=%d\n" % (cutWidth, cut))

        return (cutWidth, cut)


    def _GraphEvents(self, cmd, startDateTime, count, eventList):

        # ignore started events (i.e. that start previous day and end start day)
        while (len(eventList) and eventList[0].s < startDateTime):
            eventList = eventList[1:]

        dayDivider = ''
        for i in xrange(self.calWidth):
            dayDivider += '-'

        weekDivider = ''
        for i in xrange(7):
            weekDivider += '+'
            weekDivider += dayDivider
        weekDivider += '+'
        weekDivider = str(self.borderColor) + weekDivider + str(CLR_NRM())

        empty = ''
        for i in xrange(self.calWidth):
            empty += ' '

        dayFormat = '%-' + str(self.calWidth) + '.' + str(self.calWidth) + 's'

        # Get the localized day names... January 1, 2001 was a Monday
        dayNames = [ date(2001, 1, i+1).strftime('%A') for i in range(7) ]
        dayNames = dayNames[6:] + dayNames[:6]

        dayHeader = str(self.borderColor) + '|' + str(CLR_NRM())
        for i in xrange(7):
            if self.calMonday:
                if i == 6:
                    dayName = dayFormat % (dayNames[0])
                else:
                    dayName = dayFormat % (dayNames[i+1])
            else:
                dayName = dayFormat % (dayNames[i])
            dayHeader += str(self.dateColor) + dayName + str(CLR_NRM())
            dayHeader += str(self.borderColor) + '|' + str(CLR_NRM())

        PrintMsg(CLR_NRM(), "\n" + weekDivider + "\n")
        if cmd == 'calm':
            m = startDateTime.strftime('%B %Y')
            mw = str((self.calWidth * 7) + 6)
            mwf = '%-' + mw + '.' + mw + 's'
            PrintMsg(CLR_NRM(),
                     str(self.borderColor) + '|' + str(CLR_NRM()) +
                     str(self.dateColor) + mwf % (m) + str(CLR_NRM()) +
                     str(self.borderColor) + '|' + str(CLR_NRM()) + '\n')
            PrintMsg(CLR_NRM(), weekDivider + "\n")
        PrintMsg(CLR_NRM(), dayHeader + "\n")
        PrintMsg(CLR_NRM(), weekDivider + "\n")

        curMonth = startDateTime.strftime("%b")

        # get date range objects for the first week
        if cmd == 'calm':
            dayNum = int(startDateTime.strftime("%w"))
            if self.calMonday:
                dayNum -= 1
                if dayNum < 0:
                    dayNum = 6
            startDateTime = (startDateTime - timedelta(days=dayNum))
        startWeekDateTime = startDateTime
        endWeekDateTime = (startWeekDateTime + timedelta(days=7))

        for i in xrange(count):

            # create/print date line
            line = str(self.borderColor) + '|' + str(CLR_NRM())
            for j in xrange(7):
                if cmd == 'calw':
                    d = (startWeekDateTime +
                         timedelta(days=j)).strftime("%d %b")
                else: # (cmd == 'calm'):
                    d = (startWeekDateTime +
                         timedelta(days=j)).strftime("%d")
                    if curMonth != (startWeekDateTime + \
                                    timedelta(days=j)).strftime("%b"):
                        d = ''
                todayMarker = ''
                if self.now.strftime("%d%b%Y") == \
                   (startWeekDateTime + timedelta(days=j)).strftime("%d%b%Y"):
                    todayMarker = " **"
                line += str(self.dateColor) + \
                            dayFormat % (d + todayMarker) + \
                        str(CLR_NRM()) + \
                        str(self.borderColor) + \
                            '|' + \
                        str(CLR_NRM())
            PrintMsg(CLR_NRM(), line + "\n")

            weekColorStrings = [ '', '', '', '', '', '', '' ]
            weekEventStrings = self._GetWeekEventStrings(cmd, curMonth,
                                                         startWeekDateTime,
                                                         endWeekDateTime,
                                                         eventList)

            # convert the strings to unicode for various string ops
            for j in xrange(7):
                weekEventStrings[j] = unicode(weekEventStrings[j],
                                              locale.getpreferredencoding())

            # get date range objects for the next week
            startWeekDateTime = endWeekDateTime
            endWeekDateTime = (endWeekDateTime + timedelta(days=7))

            while 1:

                done = True
                line = str(self.borderColor) + '|' + str(CLR_NRM())

                for j in xrange(7):

                    if weekEventStrings[j] == '':
                        weekColorStrings[j] = ''
                        line += empty + \
                                str(self.borderColor) + '|' + str(CLR_NRM())
                        continue

                    # get/skip over a color sequence
                    if ((not CLR.conky and weekEventStrings[j][0] == '\033') or
                        (    CLR.conky and weekEventStrings[j][0] == '$')):
                        weekColorStrings[j] = ''
                        while ((not CLR.conky and weekEventStrings[j][0] != 'm') or
                               (    CLR.conky and weekEventStrings[j][0] != '}')):
                            weekColorStrings[j] += weekEventStrings[j][0]
                            weekEventStrings[j] = weekEventStrings[j][1:]
                        weekColorStrings[j] += weekEventStrings[j][0]
                        weekEventStrings[j] = weekEventStrings[j][1:]

                    if weekEventStrings[j][0] == '\n':
                        weekColorStrings[j] = ''
                        weekEventStrings[j] = weekEventStrings[j][1:]
                        line += empty + \
                                str(self.borderColor) + '|' + str(CLR_NRM())
                        done = False
                        continue

                    weekEventStrings[j] = weekEventStrings[j].lstrip()

                    printLen, cut = self._GetCutIndex(weekEventStrings[j])
                    padding = ' ' * (self.calWidth - printLen)

                    line += weekColorStrings[j] + \
                            weekEventStrings[j][:cut] + \
                            padding + \
                            str(CLR_NRM())
                    weekEventStrings[j] = weekEventStrings[j][cut:]

                    done = False
                    line += str(self.borderColor) + '|' + str(CLR_NRM())

                if done:
                    break

                PrintMsg(CLR_NRM(), line + "\n")

            PrintMsg(CLR_NRM(), weekDivider + "\n")

    def _tsv(self, startDateTime, eventList):
        # tab-separated output for easier shellscripting.
        # Format:
        # "Date" "start" "end" "Event-Title" "Location" "Eventdescription"
        dayFormat = '%F'

        for event in eventList:
            tmpLink = event.GetHtmlLink().href
            if self.detailUrl == "short":
                tmpLink = ShortenURL(tmpLink)
            tmpDayStr = event.s.strftime(dayFormat)
            tmpDayEnd = event.e.strftime(dayFormat)
            tmpTimeStr = event.s.strftime("%H:%M")
            tmpTimeStp = event.e.strftime("%H:%M")

            if event.where and len(event.where) > 0 and \
               event.where[0].value_string:
                tmpWhere = event.where[0].value_string
            else:
                tmpWhere = ''
            if event.content and event.content.text:
                tmpContent = event.content.text
            else:
                tmpContent = ''
            str = "%s\t%s\t%s\t%s\t%s\t%s\t%s" % (
                tmpDayStr,
                tmpTimeStr,
                tmpDayEnd,
                tmpTimeStp,
                tmpLink,
                self._ValidTitle(event.title.text).strip(),
                tmpWhere,
                tmpContent
            )
            str2 = "%s\n" % str.replace('\n', '''\\n''')
            sys.stdout.write(str2)

    def _PrintEvents(self, startDateTime, eventList, yearDate=False):

        def formatDescr(descr, indent, box):
            wrapper = textwrap.TextWrapper()
            if box:
                wrapper.initial_indent = (indent + '  ')
                wrapper.subsequent_indent = (indent + '  ')
                wrapper.width = (self.detailDescrWidth - 2)
            else:
                wrapper.initial_indent = indent
                wrapper.subsequent_indent = indent
                wrapper.width = self.detailDescrWidth
            new_descr = ""
            for line in descr.split("\n"):
                if box:
                    tmpLine = wrapper.fill(line)
                    for singleLine in tmpLine.split("\n"):
                        singleLine = singleLine.ljust(self.detailDescrWidth,' ')
                        new_descr += singleLine[:len(indent)] + \
                                     '|' + \
                                     singleLine[(len(indent)+1) :
                                                (self.detailDescrWidth-1)] + \
                                     '|' + '\n'
                else:
                    new_descr += wrapper.fill(line) + "\n"
            return new_descr.rstrip()

        if len(eventList) == 0:
            PrintMsg(CLR_YLW(), "\nNo Events Found...\n")
            return

        dayFormat = '\n%F' if yearDate else '\n%a %b %d' # 10 chars for day
        indent = '          ' # 10 spaces
        detailsIndent = '                   '    # 19 spaces
        day = ''

        for event in eventList:

            if self.ignoreStarted and (event.s < startDateTime):
                continue

            tmpDayStr = event.s.strftime(dayFormat)

            if self.military:
                timeFormat = '%-5s'
                tmpTimeStr = event.s.strftime("%H:%M")
            else:
                timeFormat = '%-7s'
                tmpTimeStr = \
                    event.s.strftime("%I:%M").lstrip('0').rjust(5) + \
                    event.s.strftime('%p').lower()

            prefix = indent
            if tmpDayStr != day: day = prefix = tmpDayStr
            PrintMsg(self.dateColor, prefix)
            if event.s.hour == 0 and event.s.minute == 0 and \
               event.e.hour == 0 and event.e.minute == 0:
                fmt = '  ' + timeFormat + '  %s\n'
                PrintMsg(self._CalendarColor(event.gcalcli_cal), fmt %
                         ('', self._ValidTitle(event.title.text).strip()))
            else:
                fmt = '  ' + timeFormat + '  %s\n'
                PrintMsg(self._CalendarColor(event.gcalcli_cal), fmt %
                         (tmpTimeStr, self._ValidTitle(event.title.text).strip()))

            if self.detailUrl:
                hLink = event.GetHtmlLink().href
                if self.detailUrl == "short":
                    hLink = ShortenURL(hLink)
                str = "%s  Link: %s\n" % (detailsIndent, hLink)
                PrintMsg(CLR_NRM(), str)

            if self.detailLocation:
                if event.where and len(event.where) > 0 and \
                   event.where[0].value_string:
                    str = "%s  Location: %s\n" % (
                        detailsIndent,
                        event.where[0].value_string
                    )
                    PrintMsg(CLR_NRM(), str)

            if self.detailLength:
                diffDateTime = (event.e - event.s)
                str = "%s  Length: %s\n" % (detailsIndent, diffDateTime)
                PrintMsg(CLR_NRM(), str)

            if self.detailReminders:
                reminders = []
                if event.when and len(event.when) > 0 and \
                   hasattr(event.when[0], 'reminder'):
                    reminders = event.when[0].reminder
                for rem in reminders:
                    remStr = ''
                    if rem.days:
                        remStr += "%s Days" % (rem.days)
                    if rem.hours:
                        if remStr != '': remStr += ' '
                        remStr += "%s Hours" % (rem.hours)
                    if rem.minutes:
                        if remStr != '': remStr += ' '
                        remStr += "%s Minutes" % (rem.minutes)
                    str = "%s  Reminder: %s\n" % (detailsIndent, remStr)
                    PrintMsg(CLR_NRM(), str)

            if self.detailDescr:
                if event.content and event.content.text and event.content.text.strip():
                    descrIndent = detailsIndent + '  '
                    marker = descrIndent + '-' * \
                             (self.detailDescrWidth - len(descrIndent))
                    box = True # leave old non-box code for option later
                    if box:
                        marker = marker[:len(descrIndent)] + \
                                 '+' + \
                                 marker[(len(descrIndent)+1) :
                                        (self.detailDescrWidth-1)] + \
                                 '+'
                    str = "%s  Description:\n%s\n%s\n%s\n" % (
                        detailsIndent,
                        marker,
                        formatDescr(event.content.text, descrIndent, box),
                        marker
                    )
                    PrintMsg(CLR_NRM(), str)


    def _GetAllEvents(self, cal, feed, end):

        eventList = []

        while 1:
            next = feed.GetNextLink()

            for event in feed.entry:

                event.gcalcli_cal = cal

                event.s = parse(event.when[0].start_time)
                if event.s.tzinfo == None:
                    event.s = event.s.replace(tzinfo=tzlocal())
                else:
                    event.s = event.s.astimezone(tzlocal())

                event.e = parse(event.when[0].end_time)
                if event.e.tzinfo == None:
                    event.e = event.e.replace(tzinfo=tzlocal())
                else:
                    event.e = event.e.astimezone(tzlocal())

                # For all-day events, Google seems to assume that the event time
                # is based in the UTC instead of the local timezone.  Here we
                # filter out those events start beyond a specified end time.
                if end and (event.s >= end):
                    continue

                # http://en.wikipedia.org/wiki/Year_2038_problem
                # Catch the year 2038 problem here as the python dateutil module
                # can choke throwing a ValueError exception. If either the start
                # or end time for an event has a year '>= 2038' dump it.
                if event.s.year >= 2038 or event.e.year >= 2039:
                    continue

                eventList.append(event)

            if not next:
                break

            feed = self.gcal.GetCalendarEventFeed(next.href)

        return eventList


    def _SearchForCalEvents(self, start, end, searchText):

        eventList = []

        queue = Queue()
        threads = []

        def worker(cal, query):
            feed = self.gcal.CalendarQuery(query)
            queue.put((cal, feed))

        for cal in self.cals:

            if not self._CalendarWithinAccess(cal):
                continue

            # http://code.google.com/apis/calendar/reference.html
            if not searchText:
                query = CalendarEventQuery(cal.gcalcli_username,
                                           cal.gcalcli_visibility,
                                           cal.gcalcli_projection)
                query.start_min = start.isoformat()
                query.start_max = end.isoformat()
            else:
                query = CalendarEventQuery(cal.gcalcli_username,
                                           cal.gcalcli_visibility,
                                           cal.gcalcli_projection,
                                           searchText)
                if start: # flagged by --ignore-started
                    # weeds out old but still pulls in started events
                    query.futureevents = 'true'

            query.singleevents = 'true'

            # we sort later after getting events from all calendars
            #query.orderby = 'starttime'
            #query.sortorder = 'ascending'

            th = threading.Thread(target=worker, args=(cal, query))
            threads.append(th)
            th.start()

        for th in threads:
            th.join()

        while not queue.empty():
            cal, feed = queue.get()
            eventList.extend(self._GetAllEvents(cal, feed, end))

        eventList.sort(lambda x, y: cmp(x.s, y.s))

        return eventList


    def ListAllCalendars(self):

        accessLen = 0

        for cal in self.allCals.entry:
            length = len(cal.access_level.value)
            if length > accessLen: accessLen = length

        if accessLen < len('Access'): accessLen = len('Access')

        format = ' %0' + str(accessLen) + 's  %s\n'

        PrintMsg(CLR_BRYLW(), "\n" + format % ('Access', 'Title'))
        PrintMsg(CLR_BRYLW(), format % ('------', '-----'))

        for cal in self.allCals.entry:
            PrintMsg(self._CalendarColor(cal),
                     format % (cal.access_level.value, cal.title.text))


    def TextQuery(self, searchText=''):

        # the empty string would get *ALL* events...
        if searchText == '':
            return

        if self.ignoreStarted:
            start = self.now # flags gdata futureevents to true
        else:
            start = None

        eventList = \
            self._SearchForCalEvents(start, None, searchText)

        self._PrintEvents(self.now, eventList, yearDate=True)


    def AgendaQuery(self, startText='', endText=''):
        if startText == '':
            if self.ignoreStarted:
                start = self.now
            else:
                # convert now to midnight this morning and use for default
                start = self.now.replace(hour=0,
                                         minute=0,
                                         second=0,
                                         microsecond=0)
        else:
            try:
                start = self.dateParser.fromString(startText, not self.ignoreStarted)
            except:
                PrintErrMsg('Error: failed to parse start time\n')
                return

        if endText == '':
            end = (start + timedelta(days=self.agendaLength))
        else:
            try:
                end = self.dateParser.fromString(endText, not self.ignoreStarted)
            except:
                PrintErrMsg('Error: failed to parse end time\n')
                return

        eventList = self._SearchForCalEvents(start, end, None)

        if self.tsv:
            self._tsv(start, eventList)
        else:
            self._PrintEvents(start, eventList, yearDate=False)


    def CalQuery(self, cmd, startText='', count=1):

        if startText == '':
            # convert now to midnight this morning and use for default
            start = self.now.replace(hour=0,
                                     minute=0,
                                     second=0,
                                     microsecond=0)
        else:
            try:
                start = self.dateParser.fromString(startText)
                start = start.replace(hour=0, minute=0, second=0, microsecond=0)
            except:
                PrintErrMsg('Error: failed to parse start time\n')
                return

        # convert start date to the beginning of the week or month
        if cmd == 'calw':
            dayNum = int(start.strftime("%w"))
            if self.calMonday:
                dayNum -= 1
                if dayNum < 0:
                    dayNum = 6
            start = (start - timedelta(days=dayNum))
            end = (start + timedelta(days=(count * 7)))
        else: # cmd == 'calm':
            start = (start - timedelta(days=(start.day - 1)))
            endMonth = (start.month + 1)
            endYear = start.year
            if endMonth == 13:
                endMonth = 1
                endYear += 1
            end = start.replace(month=endMonth, year=endYear)
            daysInMonth = (end - start).days
            offsetDays = int(start.strftime('%w'))
            if self.calMonday:
                offsetDays -= 1
                if offsetDays < 0:
                    offsetDays = 6
            totalDays = (daysInMonth + offsetDays)
            count = (totalDays / 7)
            if totalDays % 7:
                count += 1

        eventList = self._SearchForCalEvents(start, end, None)

        self._GraphEvents(cmd, start, count, eventList)


    def _InsertEvent(self, event):
        for i in range(0,6):
            if i != 0:
                time.sleep(i)
            try:
                newEvent = self.gcal.InsertEvent(event, self._TargetCalendar())
                url = ShortenURL(newEvent.GetHtmlLink().href)
                PrintMsg(CLR_GRN(), 'New event added: %s\n' % url)
                return newEvent
            except Exception, e:
                PrintErrMsg("Insert error: %s\n" % (e[0]["reason"]))
                #PrintErrMsg("Error: %s\n" % (e[0]["body"]))
                continue

        PrintErrMsg('Failed to add event!\n')
        return None


    def _UpdateEvent(self, event):
        for i in range(0,6):
            if i != 0:
                time.sleep(i)
            try:
                self.gcal.UpdateEvent(event.GetEditLink().href, event)
                return True
            except Exception, e:
                PrintErrMsg("Update error: %s\n" % (e[0]["reason"]))
                PrintErrMsg("Error: %s\n" % (e[0]["body"]))
                continue

        PrintErrMsg('Failed to update event!\n')
        return False


    def QuickAdd(self, eventText, reminder=None):

        if eventText == '':
            return

        event = gdata.calendar.CalendarEventEntry()
        event.content = atom.Content(text=eventText)
        event.quick_add = gdata.calendar.QuickAdd(value='true')

        # XXX can't do this because of a bug in gdata 
        # http://code.google.com/a/google.com/p/apps-api-issues/issues/detail?id=2197
        # if reminder is not None:
        #   event.when.append(gdata.calendar.When())
        #   event.when[0].reminder.append(gdata.calendar.Reminder(minutes=reminder))

        newEvent = self._InsertEvent(event)

        if newEvent is not None and reminder is not None:
            if len(newEvent.when) > 0:
                for when in newEvent.when:
                    if len(when.reminder) > 0:
                        when.reminder[0].minutes = reminder
                    else:
                        when.reminder.append(gdata.calendar.Reminder(minutes=reminder))
                self._UpdateEvent(newEvent)
            else:
                pass # should not happen


    def ExtendedAdd(self, eTitle, eWhere, eStart, eEnd, eDescr, reminder):
        # https://developers.google.com/google-apps/calendar/v1/developers_guide_python#CreatingSingle
        event = gdata.calendar.CalendarEventEntry()

        event.title = atom.Title(text=eTitle)

        if eWhere:
            event.where.append(gdata.calendar.Where(value_string=eWhere))

        event.when.append(gdata.calendar.When(start_time=eStart,
                                              end_time=eEnd))
        if eDescr:
            event.content = atom.Content(text=eDescr)

        if reminder is not None:
            event.when[0].reminder.append(gdata.calendar.Reminder(minutes=reminder))

        self._InsertEvent(event)


    def Remind(self, minutes=10, command=None):

        if command == None:
            command = self.command

        # perform a date query for now + minutes + slip
        start = self.now
        end   = (start + timedelta(minutes=(minutes + 5)))

        eventList = self._SearchForCalEvents(start, end, None)

        message = ''

        for event in eventList:

            # skip this event if it already started
            # XXX maybe add a 2+ minute grace period here...
            if event.s < self.now:
                continue

            if self.military:
                tmpTimeStr = event.s.strftime('%H:%M')
            else:
                tmpTimeStr = \
                    event.s.strftime('%I:%M').lstrip('0') + \
                    event.s.strftime('%p').lower()

            message += '%s  %s\n' % \
                       (tmpTimeStr, self._ValidTitle(event.title.text).strip())

        if message == '':
            return

        cmd = shlex.split(command)

        for i, a in zip(xrange(len(cmd)), cmd):
            if a == '%s':
                cmd[i] = message

        pid = os.fork()
        if not pid:
            os.execvp(cmd[0], cmd)


    def ImportICS(self, verbose=False, reminder=None, icsFile=None):
        try:
            import vobject
        except:
            PrintErrMsg('Python vobject module not installed!\n')
            sys.exit(1)

        f = sys.stdin

        if icsFile:
            try:
                f = file(icsFile)
            except Exception, e:
                PrintErrMsg("Error: " + str(e) + "!\n")
                sys.exit(1)

        while True:

            try:
                v = vobject.readComponents(f).next()
            except StopIteration:
                break

            ve = v.vevent
            event = gdata.calendar.CalendarEventEntry()

            if hasattr(ve, 'summary'):
                DebugPrint("SUMMARY: %s\n" % ve.summary.value)
                if verbose:
                    print "Event........%s" % ve.summary.value
                event.title = atom.Title(text=ve.summary.value)

            if hasattr(ve, 'location'):
                DebugPrint("LOCATION: %s\n" % ve.location.value)
                if verbose:
                    print "Location.....%s" % ve.location.value
                event.where = gdata.calendar.Where(value_string=ve.location.value)

            if not hasattr(ve, 'dtstart') or not hasattr(ve, 'dtend'):
                PrintErrMsg("Error: event does not have a dtstart and dtend!\n")
                continue

            DebugPrint("DTSTART: %s\n" % ve.dtstart.value.isoformat())
            DebugPrint("DTEND: %s\n" % ve.dtend.value.isoformat())
            if verbose:
                print "Start........%s" % ve.dtstart.value.isoformat(' ')
                print "End..........%s" % ve.dtend.value.isoformat(' ')
                print "Local Start..%s" % ve.dtstart.value.astimezone(tzlocal())
                print "Local End....%s" % ve.dtend.value.astimezone(tzlocal())

            if hasattr(ve, 'rrule'):

                DebugPrint("RRULE: %s\n" % ve.rrule.value)
                if verbose:
                    print "Recurrence...%s" % ve.rrule.value
                    # XXX Need to print a NICE recurrence string
                    #rr = rrulestr(ve.rrule.value)
                    #print dir(rr)

                #
                # In order to add an RRULE using a DTSTART and DTEND in the
                # local timezone, there needs to be a TIMEZONE section in the
                # recurrence field. Since that is a pain and I'm lazy... as
                # a workaround I convert the DTSTART and DTEND to UTC. Google
                # handles this properly and keys off the timezone setting of
                # the calendar being added to.  The event will be shown at the
                # correct local time. :-)
                #

                if False:
                    # A TIMEZONE section is needed for this to work XXX
                    recurrence = \
                        "DTSTART;TZID=" + \
                            ve.dtstart.value.tzinfo._tzid + ":" + \
                            ve.dtstart.value.strftime('%Y%m%dT%H%M%S') + \
                            '\r\n' + \
                        "DTEND;TZID=" + \
                            ve.dtend.value.tzinfo._tzid + ":" + \
                            ve.dtend.value.strftime('%Y%m%dT%H%M%S') + \
                            '\r\n' + \
                        "RRULE:" + ve.rrule.value + '\r\n'
                else:
                    ve.dtstart.value -= ve.dtstart.value.utcoffset()
                    ve.dtstart.value = ve.dtstart.value.replace(tzinfo=None)
                    ve.dtend.value -= ve.dtend.value.utcoffset()
                    ve.dtend.value = ve.dtend.value.replace(tzinfo=None)
                    recurrence = \
                        "DTSTART:" + \
                            ve.dtstart.value.strftime('%Y%m%dT%H%M%S') + \
                            '\r\n' + \
                        "DTEND:" + \
                            ve.dtend.value.strftime('%Y%m%dT%H%M%S') + \
                            '\r\n' + \
                        "RRULE:" + ve.rrule.value + '\r\n'

                DebugPrint("RECURRENCE:\n%s\n" % recurrence)
                event.recurrence = \
                    gdata.calendar.Recurrence(text=recurrence)

            elif hasattr(ve, 'dtstart') and hasattr(ve, 'dtend'):

                start = ve.dtstart.value.isoformat()
                end   = ve.dtend.value.isoformat()
                event.when = gdata.calendar.When(start_time=start,
                                                 end_time=end)

                if reminder is not None:
                    event.when.reminder.append(gdata.calendar.Reminder(minutes=reminder))

            if hasattr(ve, 'description'):
                DebugPrint("DESCRIPTION: %s\n" % ve.description.value)
                if verbose:
                    print "Description:\n%s" % ve.description.value
                event.content = atom.Content(text=ve.description.value)

            if hasattr(ve, 'organizer'):
                DebugPrint("ORGANIZER: %s\n" % ve.organizer.value)

                if ve.organizer.value.startswith("MAILTO:"):
                    email = ve.organizer.value[7:]
                else:
                    email = ve.organizer.value
                if verbose:
                    print "organizer:\n%s" % email
                event.who.append(gdata.calendar.Who(ve.organizer.name, email, rel='ORGANIZER'))

            if hasattr(ve, 'attendee_list'):
                DebugPrint("ATTENDEE_LIST : %s\n" % ve.attendee_list)
                if verbose:
                    print "attendees:"
                for attendee in ve.attendee_list:
                    if attendee.value.startswith("MAILTO:"):
                        email = attendee.value[7:]
                    else:
                        email = attendee.value
                    if verbose:
                        print " %s" % email

                    event.who.append(gdata.calendar.Who(attendee.name, email, rel='ATTENDEE'))

            if not verbose:
                self._InsertEvent(event)
                continue

            PrintMsg(CLR_YLW(), "\n[i]mport [s]kip [q]uit: ")
            val = raw_input()
            if val == 'i':
                if not self._InsertEvent(event):
                    sys.exit(1)
            elif val == 's':
                continue
            elif val == 'q':
                sys.exit(0)
            else:
                PrintErrMsg('Error: invalid input\n')
                sys.exit(1)


def LoadConfig(configFile):

    config = RawConfigParser()
    config.read(os.path.expanduser(configFile))
    return config


def GetConfig(config, key, default):

    try:
        value = config.get('gcalcli', key)
    except:
        value = default

    if value and value.startswith('`'):
        # Value is a shell command
        cmd = value.strip()[1:-1]
        parts = []
        for part in cmd.split():
            parts.append(os.path.expanduser(part))
        value = subprocess.check_output(parts).strip()

    return value


def GetConfigMultiple(config, key, default):

    try:
        values = config.get('gcalcli', key)
    except:
        values = default

    if values == None:
        return [ None ]

    valueList = csv.reader([ values ],
                           delimiter=',',
                           quotechar='"',
                           skipinitialspace=True).next()
    return valueList


def GetTrueFalse(value):

    if value.lower() == 'false': return False
    else: return True


def GetColor(value, exitFlag):

    colors = { 'default'       : CLR_NRM(),
               'black'         : CLR_BLK(),
               'brightblack'   : CLR_BRBLK(),
               'red'           : CLR_RED(),
               'brightred'     : CLR_BRRED(),
               'green'         : CLR_GRN(),
               'brightgreen'   : CLR_BRGRN(),
               'yellow'        : CLR_YLW(),
               'brightyellow'  : CLR_BRYLW(),
               'blue'          : CLR_BLU(),
               'brightblue'    : CLR_BRBLU(),
               'magenta'       : CLR_MAG(),
               'brightmagenta' : CLR_BRMAG(),
               'cyan'          : CLR_CYN(),
               'brightcyan'    : CLR_BRCYN(),
               'white'         : CLR_WHT(),
               'brightwhite'   : CLR_BRWHT() }

    try:
        return colors[value]
    except:
        if exitFlag:
            PrintErrMsg('Error: invalid color name\n')
            sys.exit(1)
        else:
            return None


def GetCalColors(calNames):
    calColors = {}
    for calName in calNames:
        calNameParts = calName.split("#")
        calNameSimple = calNameParts[0]
        calColor = calColors.get(calNameSimple)
        if len(calNameParts) > 0:
            calColorRaw = calNameParts[-1]
            calColorNew = GetColor(calColorRaw, False)
            if calColorNew is not None:
                calColor = calColorNew
        calColors[calNameSimple] = calColor
    return calColors


def BowChickaWowWow():

    try:
        opts, args = getopt.getopt(sys.argv[1:], "",
                                   ["help",
                                    "version",
                                    "config=",
                                    "user=",
                                    "pw=",
                                    "cals=",
                                    "cal=",
                                    "24hr",
                                    "detail-all",
                                    "detail-location",
                                    "detail-length",
                                    "detail-reminders",
                                    "detail-descr",
                                    "detail-descr-width=",
                                    "detail-url=",
                                    "tsv",
                                    "ignore-started",
                                    "width=",
                                    "mon",
                                    "nc",
                                    "conky",
                                    "cal-owner-color=",
                                    "cal-editor-color=",
                                    "cal-contributor-color=",
                                    "cal-read-color=",
                                    "cal-freebusy-color=",
                                    "date-color=",
                                    "border-color=",
                                    "locale=",
                                    "reminder=",
                                    "title=",
                                    "where=",
                                    "when=",
                                    "duration=",
                                    "descr="])
    except getopt.error:
        sys.exit(1)

    configFile = '~/.gcalclirc'

    # look for config file override then load the config file
    # we do this first because command line args take precedence
    for opt, arg in opts:
        if opt == "--config": configFile = arg

    cfg = LoadConfig(configFile)

    usr           = GetConfig(cfg, 'user', None)
    pwd           = GetConfig(cfg, 'pw', None)
    access        = GetConfig(cfg, 'cals', 'all')
    calNames      = GetConfigMultiple(cfg, 'cal', None)
    military      = GetTrueFalse(GetConfig(cfg, '24hr', 'false'))
    ignoreStarted = GetTrueFalse(GetConfig(cfg, 'ignore-started', 'false'))
    calWidth      = int(GetConfig(cfg, 'width', '10'))
    calMonday     = GetTrueFalse(GetConfig(cfg, 'mon', 'false'))
    tsv           = GetTrueFalse(GetConfig(cfg, 'tsv', 'false'))
    customLocale  = GetConfig(cfg, 'locale', None)
    reminder      = GetConfig(cfg, 'reminder', None)

    detailAll        = GetTrueFalse(GetConfig(cfg, 'detail-all', 'false'))
    detailLocation   = GetTrueFalse(GetConfig(cfg, 'detail-location', 'false'))
    detailLength     = GetTrueFalse(GetConfig(cfg, 'detail-length', 'false'))
    detailReminders  = GetTrueFalse(GetConfig(cfg, 'detail-reminders', 'false'))
    detailDescr      = GetTrueFalse(GetConfig(cfg, 'detail-descr', 'false'))
    detailDescrWidth = int(GetConfig(cfg, 'detail-descr-width', '80'))
    detailUrl        = GetConfig(cfg, 'detail-url', None)

    calOwnerColor = \
        GetColor(GetConfig(cfg, 'cal-owner-color', 'cyan'), True)
    calEditorColor = \
        GetColor(GetConfig(cfg, 'cal-editor-color', 'green'), True)
    calContributorColor = \
        GetColor(GetConfig(cfg, 'cal-contributor-color', 'default'), True)
    calReadColor = \
        GetColor(GetConfig(cfg, 'cal-read-color', 'magenta'), True)
    calFreeBusyColor = \
        GetColor(GetConfig(cfg, 'cal-freebusy-color', 'default'), True)
    dateColor = \
        GetColor(GetConfig(cfg, 'date-color', 'yellow'), True)
    borderColor = \
        GetColor(GetConfig(cfg, 'border-color', 'white'), True)

    eTitle    = None
    eWhere    = None
    eWhen     = None
    eDuration = None
    eDescr    = None

    # fix wokCalNames when not specified in config file
    if len(calNames) == 1 and calNames[0] == None:
        calNames      = []
        calNameColors = []

    calNamesCommandLine = []

    # Process options
    for opt, arg in opts:

        if opt == "--help":
            Usage()

        if opt == "--version":
            Version()

        elif opt == "--user":
            usr = arg

        elif opt == "--pw":
            pwd = arg

        elif opt == "--cals":
            access = arg

        elif opt == "--cal":
            calNames.append(arg)
            calNamesCommandLine.append(arg)

        elif opt == "--24hr":
            military = True

        elif opt == "--detail-all":
            detailLocation  = True
            detailLength    = True
            detailReminders = True
            detailDescr     = True
            detailUrl       = "long"

        elif opt == "--detail-location":
            detailLocation = True

        elif opt == "--detail-length":
            detailLength = True

        elif opt == "--detail-reminders":
            detailReminders = True

        elif opt == "--detail-descr":
            detailDescr = True

        elif opt == "--detail-descr-width":
            detailDescrWidth = int(arg)

        elif opt == "--detail-url":
            detailUrl = arg

        elif opt == "--ignore-started":
            ignoreStarted = True

        elif opt == "--width":
            calWidth = int(arg)

        elif opt == "--mon":
            calMonday = True

        elif opt == "--nc":
            CLR.useColor = False

        elif opt == "--conky":
            SetConkyColors()

        elif opt == "--cal-owner-color":
            calOwnerColor = GetColor(arg, True)

        elif opt == "--cal-editor-color":
            calEditorColor = GetColor(arg, True)

        elif opt == "--cal-contributor-color":
            calContributorColor = GetColor(arg, True)

        elif opt == "--cal-read-color":
            calReadColor = GetColor(arg, True)

        elif opt == "--cal-freebusy-color":
            calFreeBusyColor = GetColor(arg, True)

        elif opt == "--date-color":
            dateColor = GetColor(arg, True)

        elif opt == "--border-color":
            borderColor = GetColor(arg, True)

        elif opt == "--tsv":
            tsv = True

        elif opt == "--locale":
            customLocale = arg

        elif opt == "--reminder":
            reminder = arg

        elif (opt == "--title"):
            eTitle = arg

        elif (opt == "--where"):
            eWhere = arg

        elif (opt == "--when"):
            eWhen = arg

        elif (opt == "--duration"):
            eDuration = arg

        elif (opt == "--descr"):
            eDescr = arg

    if usr == None:
        PrintErrMsg('Error: must specify a username\n')
        sys.exit(1)

    try:
        if pwd == None:
            pwd = getpass.getpass("Password: ")
    except Exception, e:
        PrintErrMsg("Error: " + str(e) + "!\n")
        sys.exit(1)

    if pwd == None or pwd == '':
        PrintErrMsg('Error: must specify a password\n')
        sys.exit(1)

    if detailUrl and detailUrl != 'short' and detailUrl != 'long':
        PrintErrMsg('Error: invalid detail url\n')
        sys.exit(1)

    if len(args) == 0:
        PrintErrMsg('Error: no command (--help)\n')
        sys.exit(1)

    calColors = GetCalColors(calNames)
    if len(calNamesCommandLine) > 0:
        calNames = calNamesCommandLine

    calNamesFiltered = []
    calNameColors = []
    for calName in calNames:
        calNameSimple = calName.split("#")[0]
        calNamesFiltered.append(calNameSimple)
        calNameColors.append(calColors[calNameSimple])
    calNames = calNamesFiltered

    gcal = gcalcli(username=usr,
                   password=pwd,
                   access=access,
                   calNames=calNames,
                   calNameColors=calNameColors,
                   military=military,
                   detailLocation=detailLocation,
                   detailLength=detailLength,
                   detailReminders=detailReminders,
                   detailDescr=detailDescr,
                   detailDescrWidth=detailDescrWidth,
                   detailUrl=detailUrl,
                   ignoreStarted=ignoreStarted,
                   calWidth=calWidth,
                   calMonday=calMonday,
                   calOwnerColor=calOwnerColor,
                   calEditorColor=calEditorColor,
                   calContributorColor=calContributorColor,
                   calReadColor=calReadColor,
                   calFreeBusyColor=calFreeBusyColor,
                   dateColor=dateColor,
                   borderColor=borderColor,
                   tsv=tsv,
                   customLocale=customLocale)

    if args[0] == 'list':
        gcal.ListAllCalendars()

    elif args[0] == 'search':
        if len(args) != 2:
            PrintErrMsg('Error: invalid search string\n')
            sys.exit(1)

        # allow unicode strings for input
        gcal.TextQuery(unicode(args[1], locale.getpreferredencoding()))

        sys.stdout.write('\n')

    elif args[0] == 'agenda':
        if len(args) == 3: # start and end
            gcal.AgendaQuery(startText=args[1], endText=args[2])
        elif len(args) == 2: # start
            gcal.AgendaQuery(startText=args[1])
        elif len(args) == 1: # defaults
            gcal.AgendaQuery()
        else:
            PrintErrMsg('Error: invalid agenda arguments\n')
            sys.exit(1)

        if not tsv:
            sys.stdout.write('\n')

    elif args[0] == 'calw':
        if not calWidth:
            PrintErrMsg('Error: invalid width, don\'t be an idiot!\n')
            sys.exit(1)

        if len(args) >= 2:
            try:
                count = int(args[1])
            except:
                PrintErrMsg('Error: invalid calw arguments\n')
                sys.exit(1)

        if len(args) == 3: # weeks and start
            gcal.CalQuery(args[0], count=int(args[1]), startText=args[2])
        elif len(args) == 2: # weeks
            gcal.CalQuery(args[0], count=int(args[1]))
        elif len(args) == 1: # defaults
            gcal.CalQuery(args[0])
        else:
            PrintErrMsg('Error: invalid calw arguments\n')
            sys.exit(1)

        sys.stdout.write('\n')

    elif args[0] == 'calm':
        if not calWidth:
            PrintErrMsg('Error: invalid width, don\'t be an idiot!\n')
            sys.exit(1)

        if len(args) == 2: # start
            gcal.CalQuery(args[0], startText=args[1])
        elif len(args) == 1: # defaults
            gcal.CalQuery(args[0])
        else:
            PrintErrMsg('Error: invalid calm arguments\n')
            sys.exit(1)

        sys.stdout.write('\n')

    elif args[0] == 'quick':
        if len(args) != 2:
            PrintErrMsg('Error: invalid event text\n')
            sys.exit(1)

        # allow unicode strings for input
        gcal.QuickAdd(unicode(args[1], locale.getpreferredencoding()),
                      reminder=reminder)

    elif (args[0] == 'add'):
        if eTitle == None:
            PrintMsg(CLR_YLW(), "Title: ")
            eTitle = raw_input()
        if eWhere == None:
            PrintMsg(CLR_YLW(), "Location: ")
            eWhere = raw_input()
        if eWhen == None:
            PrintMsg(CLR_YLW(), "When: ")
            eWhen = raw_input()
        if eDuration == None:
            PrintMsg(CLR_YLW(), "Duration (mins): ")
            eDuration = raw_input()
        if eDescr == None:
            PrintMsg(CLR_YLW(), "Description: ")
            eDescr = raw_input()
        if reminder == None:
            PrintMsg(CLR_YLW(), "Reminder (mins): ")
            reminder = raw_input()

        # calculate "when" time:
        eStart, eEnd = GetTimeFromStr(eWhen, eDuration)

        # allow unicode strings for input
        ueTitle = unicode(eTitle, locale.getpreferredencoding())
        ueWhere = unicode(eWhere, locale.getpreferredencoding())
        ueStart = unicode(eStart, locale.getpreferredencoding())
        ueEnd   = unicode(eEnd,   locale.getpreferredencoding())
        ueDescr = unicode(eDescr, locale.getpreferredencoding())

        # http://code.google.com/apis/calendar/data/1.0/developers_guide_python.html#CreatingSingle
        gcal.ExtendedAdd(ueTitle, ueWhere, ueStart, ueEnd, ueDescr, reminder)

    elif args[0] == 'remind':
        if len(args) == 3: # minutes and command
            gcal.Remind(int(args[1]), args[2])
        elif len(args) == 2: # minutes
            gcal.Remind(int(args[1]))
        elif len(args) == 1: # defaults
            gcal.Remind()
        else:
            PrintErrMsg('Error: invalid remind arguments\n')
            sys.exit(1)

    elif args[0] == 'import':
        args = args[1:]
        verbose = False
        if len(args) >= 1 and args[0] == "-v":
            verbose = True
            args = args[1:]
        if len(args) == 0: # stdin
            gcal.ImportICS(verbose, reminder)
        elif len(args) == 1: # ics file
            gcal.ImportICS(verbose, reminder, args[0])
        else:
            PrintErrMsg('Error: invalid import arguments\n')
            sys.exit(1)

    else:
        PrintErrMsg('Error: unknown command (--help)\n')
        sys.exit(1)


if __name__ == '__main__':
    BowChickaWowWow()

